From ad810695f7cd55173313693c0a47a07d7359f33a Mon Sep 17 00:00:00 2001
From: wangxyper <wangxyper@163.com>
Date: Sat, 29 Oct 2022 15:46:00 +0800
Subject: [PATCH] Parallel entity ticking


diff --git a/src/main/java/gg/m2ke4u/keyi/AsyncPassedThreadFactory.java b/src/main/java/gg/m2ke4u/keyi/AsyncPassedThreadFactory.java
new file mode 100644
index 000000000..9722c5c43
--- /dev/null
+++ b/src/main/java/gg/m2ke4u/keyi/AsyncPassedThreadFactory.java
@@ -0,0 +1,62 @@
+package gg.m2ke4u.keyi;
+
+import com.google.common.collect.Sets;
+import net.minecraft.server.MinecraftServer;
+import java.util.Set;
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.AtomicInteger;
+
+public class AsyncPassedThreadFactory {
+    private static final AtomicInteger threadId = new AtomicInteger();
+    private static final Set<Thread> workers = Sets.newConcurrentHashSet();
+
+    private static final ThreadFactory FACTORY = task -> {
+        Thread worker = new Thread(()->{
+            try{
+                task.run();
+            }finally {
+                workers.remove(Thread.currentThread());
+            }
+        },"Keyi-Pooled-Worker # "+threadId.getAndIncrement());
+        worker.setDaemon(true);
+        worker.setPriority(Thread.NORM_PRIORITY);
+        worker.setContextClassLoader(MinecraftServer.class.getClassLoader());
+        workers.add(worker);
+        return worker;
+    };
+
+    private static final ForkJoinPool.ForkJoinWorkerThreadFactory FORK_JOIN_WORKER_THREAD_FACTORY = pool -> {
+        ForkJoinWorkerThread workerThread = new ForkJoinWorkerThread(pool){
+            @Override
+            protected void onTermination(Throwable exception) {
+                workers.remove(Thread.currentThread());
+                super.onTermination(exception);
+            }
+        };
+        workerThread.setContextClassLoader(MinecraftServer.class.getClassLoader());
+        workerThread.setDaemon(true);
+        workerThread.setName("Keyi-Fork/Join-Worker # "+threadId.getAndIncrement());
+        workers.remove(workerThread);
+        return workerThread;
+    };
+
+    public static boolean currentThreadContains(){
+        return workers.contains(Thread.currentThread());
+    }
+
+    public static ForkJoinPool getNewPool(int threads){
+        return new ForkJoinPool(threads,FORK_JOIN_WORKER_THREAD_FACTORY,null,true);
+    }
+
+    public static ForkJoinPool getNewPool(){
+        return getNewPool(Runtime.getRuntime().availableProcessors());
+    }
+
+    public static ThreadPoolExecutor getNewPoolExecutor(int threads){
+        return (ThreadPoolExecutor) Executors.newFixedThreadPool(threads,FACTORY);
+    }
+
+    public static ThreadPoolExecutor getNewPoolExecutor(){
+        return getNewPoolExecutor(Runtime.getRuntime().availableProcessors());
+    }
+}
diff --git a/src/main/java/gg/m2ke4u/keyi/concurrent/ConcurrentTraverse.java b/src/main/java/gg/m2ke4u/keyi/concurrent/ConcurrentTraverse.java
new file mode 100644
index 000000000..bec5b88c8
--- /dev/null
+++ b/src/main/java/gg/m2ke4u/keyi/concurrent/ConcurrentTraverse.java
@@ -0,0 +1,18 @@
+package gg.m2ke4u.keyi.concurrent;
+
+import java.util.Collection;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.Executor;
+import java.util.function.Consumer;
+
+public class ConcurrentTraverse {
+    public static <E> CompletableFuture traverseAsync(Collection<E> input, Consumer<E> action, Executor executor){
+        return CompletableFuture.allOf(input.stream()
+            .map(v->CompletableFuture.runAsync(()->action.accept(v),executor))
+            .toArray(CompletableFuture[]::new));
+    }
+
+    public static <E> void traverseSync(Collection<E> input,Consumer<E> action,Executor executor){
+        traverseAsync(input,action,executor).join();
+    }
+}
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/ConcurrentCollections.java b/src/main/java/net/himeki/mcmtfabric/parallelised/ConcurrentCollections.java
new file mode 100644
index 000000000..67dd5fe62
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/ConcurrentCollections.java
@@ -0,0 +1,41 @@
+package net.himeki.mcmtfabric.parallelised;
+
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedDeque;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.stream.Collector;
+import java.util.stream.Collectors;
+
+public class ConcurrentCollections {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+
+    public static <T> Set<T> newHashSet() {
+        //LOGGER.info("Concurrent hash set created");
+        return Collections.newSetFromMap(new ConcurrentHashMap<T, Boolean>());
+    }
+
+    public static <T, U> Map<T, U> newHashMap() {
+        //LOGGER.info("Concurrent hash map created");
+        return new ConcurrentHashMap<T, U>();
+    }
+
+    public static <T> List<T> newLinkedList() {
+        LOGGER.info("Concurrent \"linked\" list created");
+        return new CopyOnWriteArrayList<T>();
+    }
+
+    public static <T> Collector<T, ?, List<T>> toList() {
+        return Collectors.toCollection(CopyOnWriteArrayList::new);
+    }
+
+    public static <T> Queue<T> newArrayDeque() {
+        LOGGER.info("Concurrent \"array\" deque created");
+        return new ConcurrentLinkedDeque<T>();
+    }
+
+}
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/ConcurrentDoublyLinkedList.java b/src/main/java/net/himeki/mcmtfabric/parallelised/ConcurrentDoublyLinkedList.java
new file mode 100644
index 000000000..22b9d217d
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/ConcurrentDoublyLinkedList.java
@@ -0,0 +1,945 @@
+package net.himeki.mcmtfabric.parallelised;
+
+/*
+ * From: http://www.java2s.com/Code/Java/Collections-Data-Structure/ConcurrentDoublyLinkedList.htm
+ *
+ * Written by Doug Lea with assistance from members of JCP JSR-166
+ * Expert Group and released to the public domain, as explained at
+ * http://creativecommons.org/licenses/publicdomain
+ *
+ * Modified to actually implement List<E>
+ */
+
+import java.util.AbstractCollection;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.ConcurrentModificationException;
+import java.util.Deque;
+import java.util.Iterator;
+import java.util.List;
+import java.util.ListIterator;
+import java.util.NoSuchElementException;
+import java.util.concurrent.atomic.AtomicReference;
+
+import org.apache.commons.lang3.NotImplementedException;
+
+/**
+ * A concurrent linked-list implementation of a {@link Deque} (double-ended
+ * queue). Concurrent insertion, removal, and access operations execute safely
+ * across multiple threads. Iterators are <i>weakly consistent</i>, returning
+ * elements reflecting the state of the deque at some point at or since the
+ * creation of the iterator. They do <em>not</em> throw
+ * {@link ConcurrentModificationException}, and may proceed concurrently with
+ * other operations.
+ *
+ * <p>
+ * This class and its iterators implement all of the <em>optional</em> methods
+ * of the {@link Collection} and {@link Iterator} interfaces. Like most other
+ * concurrent collection implementations, this class does not permit the use of
+ * <tt>null</tt> elements. because some null arguments and return values cannot
+ * be reliably distinguished from the absence of elements. Arbitrarily, the
+ * {@link Collection#remove} method is mapped to <tt>removeFirstOccurrence</tt>,
+ * and {@link Collection#add} is mapped to <tt>addLast</tt>.
+ *
+ * <p>
+ * Beware that, unlike in most collections, the <tt>size</tt> method is
+ * <em>NOT</em> a constant-time operation. Because of the asynchronous nature of
+ * these deques, determining the current number of elements requires a traversal
+ * of the elements.
+ *
+ * <p>
+ * This class is <tt>Serializable</tt>, but relies on default serialization
+ * mechanisms. Usually, it is a better idea for any serializable class using a
+ * <tt>ConcurrentLinkedDeque</tt> to instead serialize a snapshot of the
+ * elements obtained by method <tt>toArray</tt>.
+ *
+ * @author Doug Lea
+ * @param <E> the type of elements held in this collection
+ */
+
+public class ConcurrentDoublyLinkedList<E> extends AbstractCollection<E> implements List<E>, java.io.Serializable {
+
+    /*
+     * This is an adaptation of an algorithm described in Paul Martin's "A Practical
+     * Lock-Free Doubly-Linked List". Sun Labs Tech report. The basic idea is to
+     * primarily rely on next-pointers to ensure consistency. Prev-pointers are in
+     * part optimistic, reconstructed using forward pointers as needed. The main
+     * forward list uses a variant of HM-list algorithm similar to the one used in
+     * ConcurrentSkipListMap class, but a little simpler. It is also basically
+     * similar to the approach in Edya Ladan-Mozes and Nir Shavit "An Optimistic
+     * Approach to Lock-Free FIFO Queues" in DISC04.
+     *
+     * Quoting a summary in Paul Martin's tech report:
+     *
+     * All cleanups work to maintain these invariants: (1) forward pointers are the
+     * ground truth. (2) forward pointers to dead nodes can be improved by swinging
+     * them further forward around the dead node. (2.1) forward pointers are still
+     * correct when pointing to dead nodes, and forward pointers from dead nodes are
+     * left as they were when the node was deleted. (2.2) multiple dead nodes may
+     * point forward to the same node. (3) backward pointers were correct when they
+     * were installed (3.1) backward pointers are correct when pointing to any node
+     * which points forward to them, but since more than one forward pointer may
+     * point to them, the live one is best. (4) backward pointers that are out of
+     * date due to deletion point to a deleted node, and need to point further back
+     * until they point to the live node that points to their source. (5) backward
+     * pointers that are out of date due to insertion point too far backwards, so
+     * shortening their scope (by searching forward) fixes them. (6) backward
+     * pointers from a dead node cannot be "improved" since there may be no live
+     * node pointing forward to their origin. (However, it does no harm to try to
+     * improve them while racing with a deletion.)
+     *
+     *
+     * Notation guide for local variables n, b, f : a node, its predecessor, and
+     * successor s : some other successor
+     */
+
+    // Minor convenience utilities
+
+    /**
+     * Returns true if given reference is non-null and isn't a header, trailer, or
+     * marker.
+     *
+     * @param n (possibly null) node
+     * @return true if n exists as a user node
+     */
+    private static boolean usable(Node<?> n) {
+        return n != null && !n.isSpecial();
+    }
+
+    /**
+     * Throws NullPointerException if argument is null
+     *
+     * @param v the element
+     */
+    private static void checkNullArg(Object v) {
+        if (v == null)
+            throw new NullPointerException();
+    }
+
+    /**
+     * Returns element unless it is null, in which case throws
+     * NoSuchElementException.
+     *
+     * @param v the element
+     * @return the element
+     */
+    private E screenNullResult(E v) {
+        if (v == null)
+            throw new NoSuchElementException();
+        return v;
+    }
+
+    /**
+     * Creates an array list and fills it with elements of this list. Used by
+     * toArray.
+     *
+     * @return the arrayList
+     */
+    private ArrayList<E> toArrayList() {
+        ArrayList<E> c = new ArrayList<E>();
+        for (Node<E> n = header.forward(); n != null; n = n.forward())
+            c.add(n.element);
+        return c;
+    }
+
+    // Fields and constructors
+
+    private static final long serialVersionUID = 876323262645176354L;
+
+    /**
+     * List header. First usable node is at header.forward().
+     */
+    private final Node<E> header;
+
+    /**
+     * List trailer. Last usable node is at trailer.back().
+     */
+    private final Node<E> trailer;
+
+    /**
+     * Constructs an empty deque.
+     */
+    public ConcurrentDoublyLinkedList() {
+        Node<E> h = new Node<E>(null, null, null);
+        Node<E> t = new Node<E>(null, null, h);
+        h.setNext(t);
+        header = h;
+        trailer = t;
+    }
+
+    /**
+     * Constructs a deque containing the elements of the specified collection, in
+     * the order they are returned by the collection's iterator.
+     *
+     * @param c the collection whose elements are to be placed into this deque.
+     * @throws NullPointerException if <tt>c</tt> or any element within it is
+     *                              <tt>null</tt>
+     */
+    public ConcurrentDoublyLinkedList(Collection<? extends E> c) {
+        this();
+        addAll(c);
+    }
+
+    /**
+     * Prepends the given element at the beginning of this deque.
+     *
+     * @param o the element to be inserted at the beginning of this deque.
+     * @throws NullPointerException if the specified element is <tt>null</tt>
+     */
+    public void addFirst(E o) {
+        checkNullArg(o);
+        while (header.append(o) == null)
+            ;
+    }
+
+    /**
+     * Appends the given element to the end of this deque. This is identical in
+     * function to the <tt>add</tt> method.
+     *
+     * @param o the element to be inserted at the end of this deque.
+     * @throws NullPointerException if the specified element is <tt>null</tt>
+     */
+    public void addLast(E o) {
+        checkNullArg(o);
+        while (trailer.prepend(o) == null)
+            ;
+    }
+
+    /**
+     * Prepends the given element at the beginning of this deque.
+     *
+     * @param o the element to be inserted at the beginning of this deque.
+     * @return <tt>true</tt> always
+     * @throws NullPointerException if the specified element is <tt>null</tt>
+     */
+    public boolean offerFirst(E o) {
+        addFirst(o);
+        return true;
+    }
+
+    /**
+     * Appends the given element to the end of this deque. (Identical in function to
+     * the <tt>add</tt> method; included only for consistency.)
+     *
+     * @param o the element to be inserted at the end of this deque.
+     * @return <tt>true</tt> always
+     * @throws NullPointerException if the specified element is <tt>null</tt>
+     */
+    public boolean offerLast(E o) {
+        addLast(o);
+        return true;
+    }
+
+    /**
+     * Retrieves, but does not remove, the first element of this deque, or returns
+     * null if this deque is empty.
+     *
+     * @return the first element of this queue, or <tt>null</tt> if empty.
+     */
+    public E peekFirst() {
+        Node<E> n = header.successor();
+        return (n == null) ? null : n.element;
+    }
+
+    /**
+     * Retrieves, but does not remove, the last element of this deque, or returns
+     * null if this deque is empty.
+     *
+     * @return the last element of this deque, or <tt>null</tt> if empty.
+     */
+    public E peekLast() {
+        Node<E> n = trailer.predecessor();
+        return (n == null) ? null : n.element;
+    }
+
+    /**
+     * Returns the first element in this deque.
+     *
+     * @return the first element in this deque.
+     * @throws NoSuchElementException if this deque is empty.
+     */
+    public E getFirst() {
+        return screenNullResult(peekFirst());
+    }
+
+    /**
+     * Returns the last element in this deque.
+     *
+     * @return the last element in this deque.
+     * @throws NoSuchElementException if this deque is empty.
+     */
+    public E getLast() {
+        return screenNullResult(peekLast());
+    }
+
+    /**
+     * Retrieves and removes the first element of this deque, or returns null if
+     * this deque is empty.
+     *
+     * @return the first element of this deque, or <tt>null</tt> if empty.
+     */
+    public E pollFirst() {
+        for (;;) {
+            Node<E> n = header.successor();
+            if (!usable(n))
+                return null;
+            if (n.delete())
+                return n.element;
+        }
+    }
+
+    /**
+     * Retrieves and removes the last element of this deque, or returns null if this
+     * deque is empty.
+     *
+     * @return the last element of this deque, or <tt>null</tt> if empty.
+     */
+    public E pollLast() {
+        for (;;) {
+            Node<E> n = trailer.predecessor();
+            if (!usable(n))
+                return null;
+            if (n.delete())
+                return n.element;
+        }
+    }
+
+    /**
+     * Removes and returns the first element from this deque.
+     *
+     * @return the first element from this deque.
+     * @throws NoSuchElementException if this deque is empty.
+     */
+    public E removeFirst() {
+        return screenNullResult(pollFirst());
+    }
+
+    /**
+     * Removes and returns the last element from this deque.
+     *
+     * @return the last element from this deque.
+     * @throws NoSuchElementException if this deque is empty.
+     */
+    public E removeLast() {
+        return screenNullResult(pollLast());
+    }
+
+    // *** Queue and stack methods ***
+    public boolean offer(E e) {
+        return offerLast(e);
+    }
+
+    public boolean add(E e) {
+        return offerLast(e);
+    }
+
+    public E poll() {
+        return pollFirst();
+    }
+
+    public E remove() {
+        return removeFirst();
+    }
+
+    public E peek() {
+        return peekFirst();
+    }
+
+    public E element() {
+        return getFirst();
+    }
+
+    public void push(E e) {
+        addFirst(e);
+    }
+
+    public E pop() {
+        return removeFirst();
+    }
+
+    /**
+     * Removes the first element <tt>e</tt> such that <tt>o.equals(e)</tt>, if such
+     * an element exists in this deque. If the deque does not contain the element,
+     * it is unchanged.
+     *
+     * @param o element to be removed from this deque, if present.
+     * @return <tt>true</tt> if the deque contained the specified element.
+     * @throws NullPointerException if the specified element is <tt>null</tt>
+     */
+    public boolean removeFirstOccurrence(Object o) {
+        checkNullArg(o);
+        for (;;) {
+            Node<E> n = header.forward();
+            for (;;) {
+                if (n == null)
+                    return false;
+                if (o.equals(n.element)) {
+                    if (n.delete())
+                        return true;
+                    else
+                        break; // restart if interference
+                }
+                n = n.forward();
+            }
+        }
+    }
+
+    /**
+     * Removes the last element <tt>e</tt> such that <tt>o.equals(e)</tt>, if such
+     * an element exists in this deque. If the deque does not contain the element,
+     * it is unchanged.
+     *
+     * @param o element to be removed from this deque, if present.
+     * @return <tt>true</tt> if the deque contained the specified element.
+     * @throws NullPointerException if the specified element is <tt>null</tt>
+     */
+    public boolean removeLastOccurrence(Object o) {
+        checkNullArg(o);
+        for (;;) {
+            Node<E> s = trailer;
+            for (;;) {
+                Node<E> n = s.back();
+                if (s.isDeleted() || (n != null && n.successor() != s))
+                    break; // restart if pred link is suspect.
+                if (n == null)
+                    return false;
+                if (o.equals(n.element)) {
+                    if (n.delete())
+                        return true;
+                    else
+                        break; // restart if interference
+                }
+                s = n;
+            }
+        }
+    }
+
+    /**
+     * Returns <tt>true</tt> if this deque contains at least one element <tt>e</tt>
+     * such that <tt>o.equals(e)</tt>.
+     *
+     * @param o element whose presence in this deque is to be tested.
+     * @return <tt>true</tt> if this deque contains the specified element.
+     */
+    public boolean contains(Object o) {
+        if (o == null)
+            return false;
+        for (Node<E> n = header.forward(); n != null; n = n.forward())
+            if (o.equals(n.element))
+                return true;
+        return false;
+    }
+
+    /**
+     * Returns <tt>true</tt> if this collection contains no elements.
+     * <p>
+     *
+     * @return <tt>true</tt> if this collection contains no elements.
+     */
+    public boolean isEmpty() {
+        return !usable(header.successor());
+    }
+
+    /**
+     * Returns the number of elements in this deque. If this deque contains more
+     * than <tt>Integer.MAX_VALUE</tt> elements, it returns
+     * <tt>Integer.MAX_VALUE</tt>.
+     *
+     * <p>
+     * Beware that, unlike in most collections, this method is <em>NOT</em> a
+     * constant-time operation. Because of the asynchronous nature of these deques,
+     * determining the current number of elements requires traversing them all to
+     * count them. Additionally, it is possible for the size to change during
+     * execution of this method, in which case the returned result will be
+     * inaccurate. Thus, this method is typically not very useful in concurrent
+     * applications.
+     *
+     * @return the number of elements in this deque.
+     */
+    public int size() {
+        long count = 0;
+        for (Node<E> n = header.forward(); n != null; n = n.forward())
+            ++count;
+        return (count >= Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int) count;
+    }
+
+    /**
+     * Removes the first element <tt>e</tt> such that <tt>o.equals(e)</tt>, if such
+     * an element exists in this deque. If the deque does not contain the element,
+     * it is unchanged.
+     *
+     * @param o element to be removed from this deque, if present.
+     * @return <tt>true</tt> if the deque contained the specified element.
+     * @throws NullPointerException if the specified element is <tt>null</tt>
+     */
+    public boolean remove(Object o) {
+        return removeFirstOccurrence(o);
+    }
+
+    /**
+     * Appends all of the elements in the specified collection to the end of this
+     * deque, in the order that they are returned by the specified collection's
+     * iterator. The behavior of this operation is undefined if the specified
+     * collection is modified while the operation is in progress. (This implies that
+     * the behavior of this call is undefined if the specified Collection is this
+     * deque, and this deque is nonempty.)
+     *
+     * @param c the elements to be inserted into this deque.
+     * @return <tt>true</tt> if this deque changed as a result of the call.
+     * @throws NullPointerException if <tt>c</tt> or any element within it is
+     *                              <tt>null</tt>
+     */
+    public boolean addAll(Collection<? extends E> c) {
+        Iterator<? extends E> it = c.iterator();
+        if (!it.hasNext())
+            return false;
+        do {
+            addLast(it.next());
+        } while (it.hasNext());
+        return true;
+    }
+
+    /**
+     * Removes all of the elements from this deque.
+     */
+    public void clear() {
+        while (pollFirst() != null)
+            ;
+    }
+
+    /**
+     * Returns an array containing all of the elements in this deque in the correct
+     * order.
+     *
+     * @return an array containing all of the elements in this deque in the correct
+     *         order.
+     */
+    public Object[] toArray() {
+        return toArrayList().toArray();
+    }
+
+    /**
+     * Returns an array containing all of the elements in this deque in the correct
+     * order; the runtime type of the returned array is that of the specified array.
+     * If the deque fits in the specified array, it is returned therein. Otherwise,
+     * a new array is allocated with the runtime type of the specified array and the
+     * size of this deque.
+     * <p>
+     *
+     * If the deque fits in the specified array with room to spare (i.e., the array
+     * has more elements than the deque), the element in the array immediately
+     * following the end of the collection is set to null. This is useful in
+     * determining the length of the deque <i>only</i> if the caller knows that the
+     * deque does not contain any null elements.
+     *
+     * @param a the array into which the elements of the deque are to be stored, if
+     *          it is big enough; otherwise, a new array of the same runtime type is
+     *          allocated for this purpose.
+     * @return an array containing the elements of the deque.
+     * @throws ArrayStoreException  if the runtime type of a is not a supertype of
+     *                              the runtime type of every element in this deque.
+     * @throws NullPointerException if the specified array is null.
+     */
+    public <T> T[] toArray(T[] a) {
+        return toArrayList().toArray(a);
+    }
+
+    /**
+     * Returns a weakly consistent iterator over the elements in this deque, in
+     * first-to-last order. The <tt>next</tt> method returns elements reflecting the
+     * state of the deque at some point at or since the creation of the iterator.
+     * The method does <em>not</em> throw {@link ConcurrentModificationException},
+     * and may proceed concurrently with other operations.
+     *
+     * @return an iterator over the elements in this deque
+     */
+    public Iterator<E> iterator() {
+        return new CLDIterator();
+    }
+
+    final class CLDIterator implements Iterator<E> {
+        Node<E> last;
+
+        Node<E> next = header.forward();
+
+        public boolean hasNext() {
+            return next != null;
+        }
+
+        public E next() {
+            Node<E> l = last = next;
+            if (l == null)
+                throw new NoSuchElementException();
+            next = next.forward();
+            return l.element;
+        }
+
+        public void remove() {
+            Node<E> l = last;
+            if (l == null)
+                throw new IllegalStateException();
+            while (!l.delete() && !l.isDeleted())
+                ;
+        }
+    }
+
+    @Override
+    public boolean addAll(int index, Collection<? extends E> c) {
+        throw new NotImplementedException("TODO");
+    }
+
+    @Override
+    public E get(int index) {
+        Node<E> current = header.successor();
+        if (current == null) {
+            throw new IndexOutOfBoundsException();
+        }
+        for (; index > 0; index --) {
+            current = current.successor();
+            if (current == null) {
+                throw new IndexOutOfBoundsException();
+            }
+        }
+        return current.element;
+    }
+
+    @Override
+    public E set(int index, E element) {
+        throw new NotImplementedException("INVALID");
+    }
+
+    @Override
+    public void add(int index, E element) {
+        throw new NotImplementedException("INVALID");
+    }
+
+    @Override
+    public E remove(int index) {
+        throw new NotImplementedException("INVALID");
+    }
+
+    @Override
+    public int indexOf(Object o) {
+        throw new NotImplementedException("INVALID");
+    }
+
+    @Override
+    public int lastIndexOf(Object o) {
+        throw new NotImplementedException("INVALID");
+    }
+
+    @Override
+    public ListIterator<E> listIterator() {
+        throw new NotImplementedException("INVALID");
+    }
+
+    @Override
+    public ListIterator<E> listIterator(int index) {
+        throw new NotImplementedException("INVALID");
+    }
+
+    @Override
+    public List<E> subList(int fromIndex, int toIndex) {
+        throw new NotImplementedException("INVALID");
+    }
+
+}
+
+/**
+ * Linked Nodes. As a minor efficiency hack, this class opportunistically
+ * inherits from AtomicReference, with the atomic ref used as the "next" link.
+ *
+ * Nodes are in doubly-linked lists. There are three kinds of special nodes,
+ * distinguished by: * The list header has a null prev link * The list trailer
+ * has a null next link * A deletion marker has a prev link pointing to itself.
+ * All three kinds of special nodes have null element fields.
+ *
+ * Regular nodes have non-null element, next, and prev fields. To avoid visible
+ * inconsistencies when deletions overlap element replacement, replacements are
+ * done by replacing the node, not just setting the element.
+ *
+ * Nodes can be traversed by read-only ConcurrentLinkedDeque class operations
+ * just by following raw next pointers, so long as they ignore any special nodes
+ * seen along the way. (This is automated in method forward.) However, traversal
+ * using prev pointers is not guaranteed to see all live nodes since a prev
+ * pointer of a deleted node can become unrecoverably stale.
+ */
+
+class Node<E> extends AtomicReference<Node<E>> {
+
+    private static final long serialVersionUID = 6640557564507962862L;
+
+    private volatile Node<E> prev;
+
+    final E element;
+
+    /** Creates a node with given contents */
+    Node(E element, Node<E> next, Node<E> prev) {
+        super(next);
+        this.prev = prev;
+        this.element = element;
+    }
+
+    /** Creates a marker node with given successor */
+    Node(Node<E> next) {
+        super(next);
+        this.prev = this;
+        this.element = null;
+    }
+
+    /**
+     * Gets next link (which is actually the value held as atomic reference).
+     */
+    private Node<E> getNext() {
+        return get();
+    }
+
+    /**
+     * Sets next link
+     *
+     * @param n the next node
+     */
+    void setNext(Node<E> n) {
+        set(n);
+    }
+
+    /**
+     * compareAndSet next link
+     */
+    private boolean casNext(Node<E> cmp, Node<E> val) {
+        return compareAndSet(cmp, val);
+    }
+
+    /**
+     * Gets prev link
+     */
+    private Node<E> getPrev() {
+        return prev;
+    }
+
+    /**
+     * Sets prev link
+     *
+     * @param b the previous node
+     */
+    void setPrev(Node<E> b) {
+        prev = b;
+    }
+
+    /**
+     * Returns true if this is a header, trailer, or marker node
+     */
+    boolean isSpecial() {
+        return element == null;
+    }
+
+    /**
+     * Returns true if this is a trailer node
+     */
+    boolean isTrailer() {
+        return getNext() == null;
+    }
+
+    /**
+     * Returns true if this is a header node
+     */
+    boolean isHeader() {
+        return getPrev() == null;
+    }
+
+    /**
+     * Returns true if this is a marker node
+     */
+    boolean isMarker() {
+        return getPrev() == this;
+    }
+
+    /**
+     * Returns true if this node is followed by a marker, meaning that it is
+     * deleted.
+     *
+     * @return true if this node is deleted
+     */
+    boolean isDeleted() {
+        Node<E> f = getNext();
+        return f != null && f.isMarker();
+    }
+
+    /**
+     * Returns next node, ignoring deletion marker
+     */
+    private Node<E> nextNonmarker() {
+        Node<E> f = getNext();
+        return (f == null || !f.isMarker()) ? f : f.getNext();
+    }
+
+    /**
+     * Returns the next non-deleted node, swinging next pointer around any
+     * encountered deleted nodes, and also patching up successor''s prev link to
+     * point back to this. Returns null if this node is trailer so has no successor.
+     *
+     * @return successor, or null if no such
+     */
+    Node<E> successor() {
+        Node<E> f = nextNonmarker();
+        for (;;) {
+            if (f == null)
+                return null;
+            if (!f.isDeleted()) {
+                if (f.getPrev() != this && !isDeleted())
+                    f.setPrev(this); // relink f's prev
+                return f;
+            }
+            Node<E> s = f.nextNonmarker();
+            if (f == getNext())
+                casNext(f, s); // unlink f
+            f = s;
+        }
+    }
+
+    /**
+     * Returns the apparent predecessor of target by searching forward for it
+     * starting at this node, patching up pointers while traversing. Used by
+     * predecessor().
+     *
+     * @return target's predecessor, or null if not found
+     */
+    private Node<E> findPredecessorOf(Node<E> target) {
+        Node<E> n = this;
+        for (;;) {
+            Node<E> f = n.successor();
+            if (f == target)
+                return n;
+            if (f == null)
+                return null;
+            n = f;
+        }
+    }
+
+    /**
+     * Returns the previous non-deleted node, patching up pointers as needed.
+     * Returns null if this node is header so has no successor. May also return null
+     * if this node is deleted, so doesn't have a distinct predecessor.
+     *
+     * @return predecessor or null if not found
+     */
+    Node<E> predecessor() {
+        Node<E> n = this;
+        for (;;) {
+            Node<E> b = n.getPrev();
+            if (b == null)
+                return n.findPredecessorOf(this);
+            Node<E> s = b.getNext();
+            if (s == this)
+                return b;
+            if (s == null || !s.isMarker()) {
+                Node<E> p = b.findPredecessorOf(this);
+                if (p != null)
+                    return p;
+            }
+            n = b;
+        }
+    }
+
+    /**
+     * Returns the next node containing a nondeleted user element. Use for forward
+     * list traversal.
+     *
+     * @return successor, or null if no such
+     */
+    Node<E> forward() {
+        Node<E> f = successor();
+        return (f == null || f.isSpecial()) ? null : f;
+    }
+
+    /**
+     * Returns previous node containing a nondeleted user element, if possible. Use
+     * for backward list traversal, but beware that if this method is called from a
+     * deleted node, it might not be able to determine a usable predecessor.
+     *
+     * @return predecessor, or null if no such could be found
+     */
+    Node<E> back() {
+        Node<E> f = predecessor();
+        return (f == null || f.isSpecial()) ? null : f;
+    }
+
+    /**
+     * Tries to insert a node holding element as successor, failing if this node is
+     * deleted.
+     *
+     * @param element the element
+     * @return the new node, or null on failure.
+     */
+    Node<E> append(E element) {
+        for (;;) {
+            Node<E> f = getNext();
+            if (f == null || f.isMarker())
+                return null;
+            Node<E> x = new Node<E>(element, f, this);
+            if (casNext(f, x)) {
+                f.setPrev(x); // optimistically link
+                return x;
+            }
+        }
+    }
+
+    /**
+     * Tries to insert a node holding element as predecessor, failing if no live
+     * predecessor can be found to link to.
+     *
+     * @param element the element
+     * @return the new node, or null on failure.
+     */
+    Node<E> prepend(E element) {
+        for (;;) {
+            Node<E> b = predecessor();
+            if (b == null)
+                return null;
+            Node<E> x = new Node<E>(element, this, b);
+            if (b.casNext(this, x)) {
+                setPrev(x); // optimistically link
+                return x;
+            }
+        }
+    }
+
+    /**
+     * Tries to mark this node as deleted, failing if already deleted or if this
+     * node is header or trailer
+     *
+     * @return true if successful
+     */
+    boolean delete() {
+        Node<E> b = getPrev();
+        Node<E> f = getNext();
+        if (b != null && f != null && !f.isMarker() && casNext(f, new Node<E>(f))) {
+            if (b.casNext(this, f))
+                f.setPrev(b);
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * Tries to insert a node holding element to replace this node. failing if
+     * already deleted.
+     *
+     * @param newElement the new element
+     * @return the new node, or null on failure.
+     */
+    Node<E> replace(E newElement) {
+        for (;;) {
+            Node<E> b = getPrev();
+            Node<E> f = getNext();
+            if (b == null || f == null || f.isMarker())
+                return null;
+            Node<E> x = new Node<E>(newElement, f, b);
+            if (casNext(f, new Node<E>(x))) {
+                b.successor(); // to relink b
+                x.successor(); // to relink f
+                return x;
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/ConcurrentLongLinkedOpenHashSet.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/ConcurrentLongLinkedOpenHashSet.java
new file mode 100644
index 000000000..5a9cac8aa
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/ConcurrentLongLinkedOpenHashSet.java
@@ -0,0 +1,237 @@
+package net.himeki.mcmtfabric.parallelised.fastutil;
+
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.concurrent.ConcurrentSkipListSet;
+
+import it.unimi.dsi.fastutil.longs.LongArrays;
+import it.unimi.dsi.fastutil.longs.LongCollection;
+import it.unimi.dsi.fastutil.longs.LongComparator;
+import it.unimi.dsi.fastutil.longs.LongIterator;
+import it.unimi.dsi.fastutil.longs.LongIterators;
+import it.unimi.dsi.fastutil.longs.LongLinkedOpenHashSet;
+import it.unimi.dsi.fastutil.longs.LongListIterator;
+import it.unimi.dsi.fastutil.longs.LongSortedSet;
+
+public class ConcurrentLongLinkedOpenHashSet extends LongLinkedOpenHashSet {
+
+    private static final long serialVersionUID = -5532128240738069111L;
+
+    private final ConcurrentSkipListSet<Long> backing= new ConcurrentSkipListSet<Long>();
+
+    public ConcurrentLongLinkedOpenHashSet() {
+        //backing = new ConcurrentLinkedDeque<Long>();
+        //backing = new ConcurrentSkipListSet<Long>();
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final int initial) {
+        //backing = new ConcurrentLinkedDeque<Long>();
+        //backing = new ConcurrentSkipListSet<Long>();
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final int initial, final float dnc) {
+        this(initial);
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final LongCollection c) {
+        this(c.size());
+        addAll(c);
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final LongCollection c, final float f) {
+        this(c.size(), f);
+        addAll(c);
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final LongIterator i, final float f) {
+        this(16, f);
+        while (i.hasNext())
+            add(i.nextLong());
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final LongIterator i) {
+        this(i, -1);
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final Iterator<?> i, final float f) {
+        this(LongIterators.asLongIterator(i), f);
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final Iterator<?> i) {
+        this(LongIterators.asLongIterator(i));
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final long[] a, final int offset, final int length, final float f) {
+        this(length < 0 ? 0 : length, f);
+        LongArrays.ensureOffsetLength(a, offset, length);
+        for (int i = 0; i < length; i++)
+            add(a[offset + i]);
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final long[] a, final int offset, final int length) {
+        this(a, offset, length, DEFAULT_LOAD_FACTOR);
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final long[] a, final float f) {
+        this(a, 0, a.length, f);
+    }
+
+    public ConcurrentLongLinkedOpenHashSet(final long[] a) {
+        this(a, -1);
+    }
+
+    @Override
+    public boolean add(final long k) {
+        boolean out = backing.add(k);
+		/*
+		if (!firstDef) {
+			first = k;
+			firstDef = true;
+		}
+		last = k;
+		*/
+        return out;
+    }
+
+    @Override
+    public boolean addAll(LongCollection c) {
+        return addAll((Collection<Long>) c);
+    }
+
+    @Override
+    public boolean addAll(Collection<? extends Long> c) {
+        return backing.addAll(c);
+    }
+
+    @Override
+    public boolean addAndMoveToFirst(final long k) {
+        boolean out = backing.add(k);
+        //first = k;
+        return out;
+    }
+
+    @Override
+    public boolean addAndMoveToLast(final long k) {
+        boolean out = backing.add(k);
+        //last = k;
+        return out;
+    }
+
+    @Override
+    public void clear() {
+        backing.clear();
+    }
+
+    @Override
+    public LongLinkedOpenHashSet clone() {
+        return new ConcurrentLongLinkedOpenHashSet(backing.iterator());
+    }
+
+    @Override
+    public LongComparator comparator() {
+        return null;
+    }
+
+    @Override
+    public boolean contains(final long k) {
+        return backing.contains(k);
+    }
+
+    @Override
+    public long firstLong() {
+		/*
+		if (backing.size() == 0) throw new NoSuchElementException();
+		return first;
+		*/
+        return backing.first();
+    }
+
+    @Override
+    public int hashCode() {
+        return backing.hashCode();
+    }
+
+    @Override
+    public LongSortedSet headSet(long to) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return backing.isEmpty();
+    }
+
+    @Override
+    public LongListIterator iterator() {
+        return FastUtilHackUtil.wrap(backing.iterator());
+    }
+
+    @Override
+    public LongListIterator iterator(long from) {
+        throw new IllegalStateException();
+        //return FastUtilHackUtil.wrap(backing.iterator());
+    }
+
+    @Override
+    public long lastLong() {
+		/*
+		if (backing.size() == 0) throw new NoSuchElementException();
+		return last;
+		*/
+        return backing.last();
+    }
+
+    @Override
+    public boolean remove(final long k) {
+		/*
+		if (k == first) {
+			first = backing.iterator().next();
+		}
+		if (k == last) {
+			last = backing.iterator().next();
+		}
+		*/
+        return backing.remove(k);
+    }
+
+    @Override
+    public long removeFirstLong() {
+        long fl = this.firstLong();
+        this.remove(fl);
+        //first = backing.iterator().next();
+        return fl;
+    }
+
+    @Override
+    public long removeLastLong() {
+        long fl = this.lastLong();
+        this.remove(fl);
+        //last = backing.iterator().next();
+        return fl;
+    }
+
+    @Override
+    public int size() {
+        return backing.size();
+    }
+
+    @Override
+    public LongSortedSet subSet(long from, long to) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public LongSortedSet tailSet(long from) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean trim() {
+        return true;
+    }
+
+    @Override
+    public boolean trim(final int n) {
+        return true;
+    }
+}
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/ConcurrentShortHashSet.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/ConcurrentShortHashSet.java
new file mode 100644
index 000000000..f084f5114
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/ConcurrentShortHashSet.java
@@ -0,0 +1,139 @@
+package net.himeki.mcmtfabric.parallelised.fastutil;
+
+import it.unimi.dsi.fastutil.shorts.ShortCollection;
+import it.unimi.dsi.fastutil.shorts.ShortIterator;
+import it.unimi.dsi.fastutil.shorts.ShortSet;
+
+import java.util.Collection;
+import java.util.concurrent.ConcurrentHashMap;
+
+public class ConcurrentShortHashSet implements ShortSet {
+
+    ConcurrentHashMap.KeySetView<Short, Boolean> backing = new ConcurrentHashMap<Short, Integer>().newKeySet();
+
+    @Override
+    public int size() {
+        return backing.size();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return backing.isEmpty();
+    }
+
+    @Override
+    public boolean contains(Object o) {
+        return false;
+    }
+
+    @Override
+    public ShortIterator iterator() {
+        return new FastUtilHackUtil.WrappingShortIterator(backing.iterator());
+    }
+
+    @Override
+    public ShortIterator shortIterator() {
+        return null;
+    }
+
+    @Override
+    public Object[] toArray() {
+        return backing.toArray();
+    }
+
+    @Override
+    public <T> T[] toArray( T[] ts) {
+        return (T[]) backing.toArray();
+    }
+
+    @Override
+    public boolean add(Short aShort) {
+        return false;
+    }
+
+    @Override
+    public boolean remove(Object o) {
+        return false;
+    }
+
+    @Override
+    public boolean containsAll( Collection<?> collection) {
+        return backing.containsAll(collection);
+    }
+
+    @Override
+    public boolean addAll( Collection<? extends Short> collection) {
+        return backing.addAll(collection);
+    }
+
+    @Override
+    public boolean removeAll( Collection<?> collection) {
+        return backing.removeAll(collection);
+    }
+
+    @Override
+    public boolean retainAll( Collection<?> collection) {
+        return backing.retainAll(collection);
+    }
+
+    @Override
+    public void clear() {
+        backing.clear();
+
+    }
+
+    @Override
+    public boolean add(short key) {
+        return backing.add(key);
+    }
+
+    @Override
+    public boolean rem(short key) {
+        return false;
+    }
+
+    @Override
+    public boolean contains(short key) {
+        return backing.contains(key);
+    }
+
+    @Override
+    public short[] toShortArray() {
+        return new short[0];
+    }
+
+    @Override
+    public short[] toShortArray(short[] a) {
+        return new short[0];
+    }
+
+    @Override
+    public short[] toArray(short[] a) {
+        return new short[0];
+    }
+
+    @Override
+    public boolean addAll(ShortCollection c) {
+        return backing.addAll(c);
+    }
+
+    @Override
+    public boolean containsAll(ShortCollection c) {
+        return backing.containsAll(c);
+    }
+
+    @Override
+    public boolean removeAll(ShortCollection c) {
+        return backing.removeAll(c);
+    }
+
+    @Override
+    public boolean retainAll(ShortCollection c) {
+        return backing.retainAll(c);
+    }
+
+    @Override
+    public boolean remove(short k) {
+        return backing.remove(k);
+    }
+}
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/FastUtilHackUtil.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/FastUtilHackUtil.java
new file mode 100644
index 000000000..a55ea456e
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/FastUtilHackUtil.java
@@ -0,0 +1,1988 @@
+package net.himeki.mcmtfabric.parallelised.fastutil;
+
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.ListIterator;
+import java.util.Map;
+import java.util.Set;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+
+import it.unimi.dsi.fastutil.longs.*;
+import it.unimi.dsi.fastutil.shorts.ShortIterator;
+import org.apache.commons.lang3.ArrayUtils;
+
+import it.unimi.dsi.fastutil.bytes.ByteCollection;
+import it.unimi.dsi.fastutil.bytes.ByteIterator;
+import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
+import it.unimi.dsi.fastutil.ints.IntCollection;
+import it.unimi.dsi.fastutil.ints.IntIterator;
+import it.unimi.dsi.fastutil.ints.IntSet;
+import it.unimi.dsi.fastutil.ints.Int2ObjectMap.Entry;
+import it.unimi.dsi.fastutil.objects.ObjectCollection;
+import it.unimi.dsi.fastutil.objects.ObjectIterator;
+import it.unimi.dsi.fastutil.objects.ObjectSet;
+
+public class FastUtilHackUtil {
+
+    public static class ConvertingObjectSet<E, T> implements ObjectSet<T> {
+
+        Set<E> backing;
+        Function<E, T> forward;
+        Function<T, E> back;
+
+        public ConvertingObjectSet(Set<E> backing, Function<E, T> forward, Function<T, E> back) {
+            this.backing = backing;
+            this.forward = forward;
+            this.back = back;
+        }
+
+        @Override
+        public int size() {
+            return backing.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return backing.isEmpty();
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean contains(Object o) {
+            try {
+                return backing.contains(back.apply((T) o));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+        }
+
+        @Override
+        public Object[] toArray() {
+            return backing.stream().map(forward).toArray();
+        }
+
+        @Override
+        public <R> R[] toArray(R[] a) {
+            return backing.stream().map(forward).collect(Collectors.toSet()).toArray(a);
+        }
+
+        @Override
+        public boolean add(T e) {
+            return backing.add(back.apply(e));
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean remove(Object o) {
+            try {
+                return backing.remove(back.apply((T) o));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            try {
+                return backing.containsAll(c.stream().map(i -> back.apply((T) i)).collect(Collectors.toSet()));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends T> c) {
+            return backing.addAll(c.stream().map(i -> back.apply(i)).collect(Collectors.toSet()));
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            try {
+                return backing.removeAll(c.stream().map(i -> back.apply((T) i)).collect(Collectors.toSet()));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            try {
+                return backing.retainAll(c.stream().map(i -> back.apply((T) i)).collect(Collectors.toSet()));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+        }
+
+        @Override
+        public void clear() {
+            backing.clear();
+
+        }
+
+        @Override
+        public ObjectIterator<T> iterator() {
+            final Iterator<E> backg = backing.iterator();
+            return new ObjectIterator<T>() {
+
+                @Override
+                public int skip(int n) {
+                    return 0;
+                }
+
+                @Override
+                public boolean hasNext() {
+                    return backg.hasNext();
+                }
+
+                @Override
+                public T next() {
+                    return forward.apply(backg.next());
+                }
+
+                @Override
+                public void remove() {
+                    backg.remove();
+                }
+            };
+        }
+
+        @Override
+        public ObjectIterator<T> objectIterator() {
+            return null;
+        }
+
+
+    }
+
+    public static class ConvertingObjectSetFast<E,T> implements it.unimi.dsi.fastutil.longs.Long2ObjectMap.FastEntrySet<T> {
+
+        Set<E> backing;
+        Function<E, it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry<T>> forward;
+        Function<it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry<T>, E> back;
+
+        public ConvertingObjectSetFast(Set<E> backing,
+                                       Function<E, it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry<T>> forward,
+                                       Function<it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry<T>, E> back) {
+            this.backing = backing;
+            this.forward = forward;
+            this.back = back;
+        }
+
+        @Override
+        public int size() {
+            return backing.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return backing.isEmpty();
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean contains(Object o) {
+            try {
+                return backing.contains(back.apply((it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry<T>)o));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+        }
+
+        @Override
+        public Object[] toArray() {
+            return backing.stream().map(forward).toArray();
+        }
+
+        @Override
+        public <R> R[] toArray(R[] a) {
+            return backing.stream().map(forward).collect(Collectors.toSet()).toArray(a);
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean remove(Object o) {
+            try {
+                return backing.remove(back.apply((it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry<T>)o));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            try {
+                return backing.containsAll(c.stream()
+                        .map(i -> back.apply((it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry<T>) i))
+                        .collect(Collectors.toSet()));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            try {
+                return backing.removeAll(c.stream().map(i -> back
+                                .apply((it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry<T>) i))
+                        .collect(Collectors.toSet()));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            try {
+                return backing.retainAll(c.stream()
+                        .map(i -> back.apply((it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry<T>) i))
+                        .collect(Collectors.toSet()));
+            } catch (ClassCastException cce) {
+                return false;
+            }
+        }
+
+        @Override
+        public void clear() {
+            backing.clear();
+
+        }
+
+        @Override
+        public ObjectIterator<it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry<T>> iterator() {
+            final Iterator<E> backg = backing.iterator();
+            return new ObjectIterator<it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry<T>>() {
+
+                @Override
+                public int skip(int n) {
+                    return 0;
+                }
+
+                @Override
+                public boolean hasNext() {
+                    return backg.hasNext();
+                }
+
+                @Override
+                public it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry<T> next() {
+                    return forward.apply(backg.next());
+                }
+
+                @Override
+                public void remove() {
+                    backg.remove();
+                }
+            };
+        }
+
+        @Override
+        public ObjectIterator<Long2ObjectMap.Entry<T>> objectIterator() {
+            return null;
+        }
+
+        @Override
+        public boolean add(it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry<T> e) {
+            return backing.add(back.apply(e));
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry<T>> c) {
+            return backing.addAll(c.stream().map(back).collect(Collectors.toList()));
+        }
+
+        @Override
+        public ObjectIterator<it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry<T>> fastIterator() {
+            return iterator();
+        }
+
+
+    }
+
+    private static <T> Int2ObjectMap.Entry<T> intEntryForwards(Map.Entry<Integer, T> entry) {
+        return new Int2ObjectMap.Entry<T>() {
+
+            @Override
+            public T getValue() {
+                return entry.getValue();
+            }
+
+            @Override
+            public T setValue(T value) {
+                return entry.setValue(value);
+            }
+
+            @Override
+            public Integer getKey() {
+                return null;
+            }
+
+            @Override
+            public int getIntKey() {
+                return entry.getKey();
+            }
+
+            @Override
+            public boolean equals(Object obj) {
+                if (obj == entry) {
+                    return true;
+                }
+                return super.equals(obj);
+            }
+
+            @Override
+            public int hashCode() {
+                return entry.hashCode();
+            }
+        };
+    }
+
+    private static <T> Map.Entry<Integer, T> intEntryBackwards(Int2ObjectMap.Entry<T> entry) {
+        return entry;
+    }
+
+    private static <T> Long2ObjectMap.Entry<T> longEntryForwards(Map.Entry<Long, T> entry) {
+        return new Long2ObjectMap.Entry<T>() {
+
+            @Override
+            public T getValue() {
+                return entry.getValue();
+            }
+
+            @Override
+            public T setValue(T value) {
+                return entry.setValue(value);
+            }
+
+            @Override
+            public Long getKey() {
+                return null;
+            }
+
+            @Override
+            public long getLongKey() {
+                return entry.getKey();
+            }
+
+            @Override
+            public boolean equals(Object obj) {
+                if (obj == entry) {
+                    return true;
+                }
+                return super.equals(obj);
+            }
+
+            @Override
+            public int hashCode() {
+                return entry.hashCode();
+            }
+        };
+    }
+
+    private static <T> Map.Entry<Long, T> longEntryBackwards(Long2ObjectMap.Entry<T> entry) {
+        return entry;
+    }
+
+    private static Long2ByteMap.Entry longByteEntryForwards(Map.Entry<Long, Byte> entry) {
+        return new Long2ByteMap.Entry() {
+
+            @Override
+            public Byte getValue() {
+                return entry.getValue();
+            }
+
+            @Override
+            public Byte setValue(Byte value) {
+                return null;
+            }
+
+            @Override
+            public byte setValue(byte value) {
+                return entry.setValue(value);
+            }
+
+            @Override
+            public byte getByteValue() {
+                return entry.getValue();
+            }
+
+            @Override
+            public Long getKey() {
+                return null;
+            }
+
+            @Override
+            public long getLongKey() {
+                return entry.getKey();
+            }
+
+            @Override
+            public boolean equals(Object obj) {
+                if (obj == entry) {
+                    return true;
+                }
+                return super.equals(obj);
+            }
+
+            @Override
+            public int hashCode() {
+                return entry.hashCode();
+            }
+
+        };
+    }
+
+    private static <T> Map.Entry<Long, Byte> longByteEntryBackwards(Long2ByteMap.Entry entry) {
+        return entry;
+    }
+
+    private static Long2LongMap.Entry longLongEntryForwards(Map.Entry<Long, Long> entry) {
+        return new Long2LongMap.Entry() {
+
+            @Override
+            public Long getValue() {
+                return entry.getValue();
+            }
+
+            @Override
+            public Long setValue(Long value) {
+                return null;
+            }
+
+            @Override
+            public long setValue(long value) {
+                return entry.setValue(value);
+            }
+
+            @Override
+            public long getLongValue() {
+                return entry.getValue();
+            }
+
+            @Override
+            public Long getKey() {
+                return null;
+            }
+
+            @Override
+            public long getLongKey() {
+                return entry.getKey();
+            }
+
+            @Override
+            public boolean equals(Object obj) {
+                if (obj == entry) {
+                    return true;
+                }
+                return super.equals(obj);
+            }
+
+            @Override
+            public int hashCode() {
+                return entry.hashCode();
+            }
+
+        };
+    }
+
+    private static <T> Map.Entry<Long, Long> longLongEntryBackwards(Long2LongMap.Entry entry) {
+        return entry;
+    }
+
+    public static <T> ObjectSet<Int2ObjectMap.Entry<T>> entrySetIntWrap(Map<Integer, T> map) {
+        return new ConvertingObjectSet<Map.Entry<Integer, T>, Int2ObjectMap.Entry<T>>(map.entrySet(), FastUtilHackUtil::intEntryForwards, FastUtilHackUtil::intEntryBackwards);
+    }
+
+    public static <T> ObjectSet<Long2ObjectMap.Entry<T>> entrySetLongWrap(Map<Long, T> map) {
+        return new ConvertingObjectSet<Map.Entry<Long, T>, Long2ObjectMap.Entry<T>>(map.entrySet(), FastUtilHackUtil::longEntryForwards, FastUtilHackUtil::longEntryBackwards);
+    }
+
+    public static <T> it.unimi.dsi.fastutil.longs.Long2ObjectMap.FastEntrySet<T> entrySetLongWrapFast(Map<Long, T> map) {
+        return new ConvertingObjectSetFast<Map.Entry<Long, T>, T>(map.entrySet(), FastUtilHackUtil::longEntryForwards, FastUtilHackUtil::longEntryBackwards);
+    }
+
+    public static ObjectSet<Long2ByteMap.Entry> entrySetLongByteWrap(Map<Long, Byte> map) {
+        return new ConvertingObjectSet<Map.Entry<Long, Byte>, Long2ByteMap.Entry>(map.entrySet(), FastUtilHackUtil::longByteEntryForwards, FastUtilHackUtil::longByteEntryBackwards);
+    }
+
+    public static ObjectSet<Long2LongMap.Entry> entrySetLongLongWrap(Map<Long, Long> map) {
+        return new ConvertingObjectSet<Map.Entry<Long, Long>, Long2LongMap.Entry>(map.entrySet(), FastUtilHackUtil::longLongEntryForwards, FastUtilHackUtil::longLongEntryBackwards);
+    }
+
+
+    static class WrappingIntIterator implements IntIterator {
+
+        Iterator<Integer> backing;
+
+        public WrappingIntIterator(Iterator<Integer> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public boolean hasNext() {
+            return backing.hasNext();
+        }
+
+        @Override
+        public int nextInt() {
+            return backing.next();
+        }
+
+        @Override
+        public int skip(int n) {
+            return 0;
+        }
+
+        @Override
+        public Integer next() {
+            return backing.next();
+        }
+
+        @Override
+        public void remove() {
+            backing.remove();
+        }
+
+    }
+
+    static class WrappingLongIterator implements LongIterator {
+
+        Iterator<Long> backing;
+
+        public WrappingLongIterator(Iterator<Long> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public boolean hasNext() {
+            return backing.hasNext();
+        }
+
+        @Override
+        public long nextLong() {
+            return backing.next();
+        }
+
+        @Override
+        public int skip(int n) {
+            return 0;
+        }
+
+        @Override
+        public Long next() {
+            return backing.next();
+        }
+
+        @Override
+        public void remove() {
+            backing.remove();
+        }
+
+    }
+
+    static class WrappingShortIterator implements ShortIterator {
+
+        Iterator<Short> backing;
+
+        public WrappingShortIterator(Iterator<Short> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public boolean hasNext() {
+            return backing.hasNext();
+        }
+
+        @Override
+        public short nextShort() {
+            return backing.next();
+        }
+
+        @Override
+        public int skip(int n) {
+            return 0;
+        }
+
+        @Override
+        public Short next() {
+            return backing.next();
+        }
+
+        @Override
+        public void remove() {
+            backing.remove();
+        }
+
+    }
+
+    public static class WrappingIntSet implements IntSet {
+
+        Set<Integer> backing;
+
+        public WrappingIntSet(Set<Integer> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public boolean add(int key) {
+            return backing.add(key);
+        }
+
+        @Override
+        public boolean rem(int key) {
+            return false;
+        }
+
+        @Override
+        public boolean contains(int key) {
+            return backing.contains(key);
+        }
+
+        @Override
+        public int[] toIntArray() {
+            return backing.stream().mapToInt(i -> i).toArray();
+        }
+
+        @Override
+        public int[] toIntArray(int[] a) {
+            if (a.length >= size()) {
+                return null;
+            } else {
+                return toIntArray();
+            }
+        }
+
+        @Override
+        public int[] toArray(int[] a) {
+            return toIntArray(a);
+        }
+
+        @Override
+        public boolean addAll(IntCollection c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean containsAll(IntCollection c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean removeAll(IntCollection c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(IntCollection c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public int size() {
+            return backing.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return backing.isEmpty();
+        }
+
+        @Override
+        public boolean contains(Object o) {
+            return false;
+        }
+
+        @Override
+        public Object[] toArray() {
+            return backing.toArray();
+        }
+
+        @Override
+        public <T> T[] toArray(T[] a) {
+            return backing.toArray(a);
+        }
+
+        @Override
+        public boolean add(Integer integer) {
+            return false;
+        }
+
+        @Override
+        public boolean remove(Object o) {
+            return false;
+        }
+
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends Integer> c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public void clear() {
+            backing.clear();
+        }
+
+        @Override
+        public IntIterator iterator() {
+            return new WrappingIntIterator(backing.iterator());
+        }
+
+        @Override
+        public IntIterator intIterator() {
+            return null;
+        }
+
+        @Override
+        public boolean remove(int k) {
+            return backing.remove(k);
+        }
+
+    }
+
+    public static LongSet wrapLongSet(Set<Long> longset) {
+        return new WrappingLongSet(longset);
+    }
+
+    public static class WrappingLongSet implements LongSet {
+
+        Set<Long> backing;
+
+        public WrappingLongSet(Set<Long> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public boolean add(long key) {
+            return backing.add(key);
+        }
+
+        @Override
+        public boolean rem(long key) {
+            return false;
+        }
+
+        @Override
+        public boolean contains(long key) {
+            return backing.contains(key);
+        }
+
+        @Override
+        public long[] toLongArray() {
+            return backing.stream().mapToLong(i -> i).toArray();
+        }
+
+        @Override
+        public long[] toLongArray(long[] a) {
+            if (a.length >= size()) {
+                return null;
+            } else {
+                return toLongArray();
+            }
+        }
+
+        @Override
+        public long[] toArray(long[] a) {
+            return toLongArray(a);
+        }
+
+        @Override
+        public boolean addAll(LongCollection c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean containsAll(LongCollection c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean removeAll(LongCollection c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(LongCollection c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public int size() {
+            return backing.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return backing.isEmpty();
+        }
+
+        @Override
+        public boolean contains(Object o) {
+            return false;
+        }
+
+        @Override
+        public Object[] toArray() {
+            return backing.toArray();
+        }
+
+        @Override
+        public <T> T[] toArray(T[] a) {
+            return backing.toArray(a);
+        }
+
+        @Override
+        public boolean add(Long aLong) {
+            return false;
+        }
+
+        @Override
+        public boolean remove(Object o) {
+            return false;
+        }
+
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends Long> c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public void clear() {
+            backing.clear();
+        }
+
+        @Override
+        public LongIterator iterator() {
+            return new WrappingLongIterator(backing.iterator());
+        }
+
+        @Override
+        public LongIterator longIterator() {
+            return null;
+        }
+
+        @Override
+        public boolean remove(long k) {
+            return backing.remove(k);
+        }
+
+    }
+
+    public static LongSortedSet wrapLongSortedSet(Set<Long> longset) {
+        return new WrappingLongSortedSet(longset);
+    }
+
+    public static class WrappingLongSortedSet implements LongSortedSet {
+
+        Set<Long> backing;
+
+        public WrappingLongSortedSet(Set<Long> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public boolean add(long key) {
+            return backing.add(key);
+        }
+
+        @Override
+        public boolean rem(long key) {
+            return false;
+        }
+
+        @Override
+        public boolean contains(long key) {
+            return backing.contains(key);
+        }
+
+        @Override
+        public long[] toLongArray() {
+            return backing.stream().mapToLong(i -> i).toArray();
+        }
+
+        @Override
+        public long[] toLongArray(long[] a) {
+            if (a.length >= size()) {
+                return null;
+            } else {
+                return toLongArray();
+            }
+        }
+
+        @Override
+        public long[] toArray(long[] a) {
+            return toLongArray(a);
+        }
+
+        @Override
+        public boolean addAll(LongCollection c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean containsAll(LongCollection c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean removeAll(LongCollection c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(LongCollection c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public int size() {
+            return backing.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return backing.isEmpty();
+        }
+
+        @Override
+        public boolean contains(Object o) {
+            return false;
+        }
+
+        @Override
+        public Object[] toArray() {
+            return backing.toArray();
+        }
+
+        @Override
+        public <T> T[] toArray(T[] a) {
+            return backing.toArray(a);
+        }
+
+        @Override
+        public boolean add(Long aLong) {
+            return false;
+        }
+
+        @Override
+        public boolean remove(Object o) {
+            return false;
+        }
+
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends Long> c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public void clear() {
+            backing.clear();
+        }
+
+        @Override
+        public boolean remove(long k) {
+            return backing.remove(k);
+        }
+
+        @Override
+        public LongBidirectionalIterator iterator(long fromElement) {
+            throw new UnsupportedOperationException();
+            //return FastUtilHackUtil.wrap(new LinkedList<Long>(backing).iterator());
+        }
+
+        @Override
+        public LongBidirectionalIterator longIterator() {
+            return null;
+        }
+
+        @Override
+        public LongBidirectionalIterator iterator() {
+            return FastUtilHackUtil.wrap(new LinkedList<Long>(backing).iterator());
+        }
+
+        @Override
+        public LongSortedSet subSet(Long fromElement, Long toElement) {
+            return null;
+        }
+
+        @Override
+        public LongSortedSet headSet(Long toElement) {
+            return null;
+        }
+
+        @Override
+        public LongSortedSet tailSet(Long fromElement) {
+            return null;
+        }
+
+        @Override
+        public Long first() {
+            return null;
+        }
+
+        @Override
+        public Long last() {
+            return null;
+        }
+
+        @Override
+        public LongSortedSet subSet(long fromElement, long toElement) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public LongSortedSet headSet(long toElement) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public LongSortedSet tailSet(long fromElement) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public LongComparator comparator() {
+            return null;
+        }
+
+        @Override
+        public long firstLong() {
+            return backing.stream().findAny().get();
+        }
+
+        @Override
+        public long lastLong() {
+            return backing.stream().findAny().get();
+        }
+
+    }
+
+    public static IntSet wrapIntSet(Set<Integer> intset) {
+        return new WrappingIntSet(intset);
+    }
+
+    public static class WrappingObjectCollection<V> implements ObjectCollection<V> {
+
+        Collection<V> backing;
+
+        public WrappingObjectCollection(Collection<V> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public int size() {
+            return backing.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return backing.isEmpty();
+        }
+
+        @Override
+        public boolean contains(Object o) {
+            return backing.contains(o);
+        }
+
+        @Override
+        public Object[] toArray() {
+            return backing.toArray();
+        }
+
+        @Override
+        public <T> T[] toArray(T[] a) {
+            return backing.toArray(a);
+        }
+
+        @Override
+        public boolean add(V e) {
+            return backing.add(e);
+        }
+
+        @Override
+        public boolean remove(Object o) {
+            return backing.remove(o);
+        }
+
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends V> c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public void clear() {
+            backing.clear();
+        }
+
+        @Override
+        public ObjectIterator<V> iterator() {
+            return FastUtilHackUtil.itrWrap(backing);
+        }
+
+        @Override
+        public ObjectIterator<V> objectIterator() {
+            return null;
+        }
+
+    }
+
+    public static <K> ObjectCollection<K> wrap(Collection<K> c) {
+        return new WrappingObjectCollection<K>(c);
+    }
+
+    public static class WrappingByteCollection implements ByteCollection {
+
+        Collection<Byte> backing;
+
+        public WrappingByteCollection(Collection<Byte> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public int size() {
+            return backing.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return backing.isEmpty();
+        }
+
+        @Override
+        public boolean contains(Object o) {
+            return false;
+        }
+
+        @Override
+        public boolean contains(byte o) {
+            return backing.contains(o);
+        }
+
+        @Override
+        public Object[] toArray() {
+            return backing.toArray();
+        }
+
+        @Override
+        public <T> T[] toArray(T[] a) {
+            return backing.toArray(a);
+        }
+
+        @Override
+        public boolean add(Byte aByte) {
+            return false;
+        }
+
+        @Override
+        public boolean add(byte e) {
+            return backing.add(e);
+        }
+
+        @Override
+        public boolean remove(Object o) {
+            return backing.remove(o);
+        }
+
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends Byte> c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public void clear() {
+            backing.clear();
+        }
+
+        @Override
+        public ByteIterator iterator() {
+            return FastUtilHackUtil.itrByteWrap(backing);
+        }
+
+        @Override
+        public ByteIterator byteIterator() {
+            return null;
+        }
+
+        @Override
+        public boolean rem(byte key) {
+            return this.remove(key);
+        }
+
+        @Override
+        public byte[] toByteArray() {
+            return null;
+        }
+
+        @Override
+        public byte[] toByteArray(byte[] a) {
+            return toArray(a);
+        }
+
+        @Override
+        public byte[] toArray(byte[] a) {
+            return ArrayUtils.toPrimitive(backing.toArray(new Byte[0]));
+        }
+
+        @Override
+        public boolean addAll(ByteCollection c) {
+            return addAll((Collection<Byte>) c);
+        }
+
+        @Override
+        public boolean containsAll(ByteCollection c) {
+            return containsAll((Collection<Byte>) c);
+        }
+
+        @Override
+        public boolean removeAll(ByteCollection c) {
+            return removeAll((Collection<Byte>) c);
+        }
+
+        @Override
+        public boolean retainAll(ByteCollection c) {
+            return retainAll((Collection<Byte>) c);
+        }
+
+    }
+
+    public static ByteCollection wrapBytes(Collection<Byte> c) {
+        return new WrappingByteCollection(c);
+    }
+
+    public static class WrappingIntCollection implements IntCollection {
+
+        Collection<Integer> backing;
+
+        public WrappingIntCollection(Collection<Integer> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public int size() {
+            return backing.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return backing.isEmpty();
+        }
+
+        @Override
+        public boolean contains(Object o) {
+            return false;
+        }
+
+        @Override
+        public boolean contains(int o) {
+            return backing.contains(o);
+        }
+
+        @Override
+        public Object[] toArray() {
+            return backing.toArray();
+        }
+
+        @Override
+        public <T> T[] toArray(T[] a) {
+            return backing.toArray(a);
+        }
+
+        @Override
+        public boolean add(Integer integer) {
+            return false;
+        }
+
+        @Override
+        public boolean add(int e) {
+            return backing.add(e);
+        }
+
+        @Override
+        public boolean remove(Object o) {
+            return backing.remove(o);
+        }
+
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends Integer> c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public void clear() {
+            backing.clear();
+        }
+
+        @Override
+        public IntIterator iterator() {
+            return FastUtilHackUtil.itrIntWrap(backing);
+        }
+
+        @Override
+        public IntIterator intIterator() {
+            return null;
+        }
+
+        @Override
+        public boolean rem(int key) {
+            return this.remove(key);
+        }
+
+        @Override
+        public int[] toIntArray() {
+            return null;
+        }
+
+        @Override
+        public int[] toIntArray(int[] a) {
+            return toArray(a);
+        }
+
+        @Override
+        public int[] toArray(int[] a) {
+            return ArrayUtils.toPrimitive(backing.toArray(new Integer[0]));
+        }
+
+        @Override
+        public boolean addAll(IntCollection c) {
+            return addAll((Collection<Integer>) c);
+        }
+
+        @Override
+        public boolean containsAll(IntCollection c) {
+            return containsAll((Collection<Integer>) c);
+        }
+
+        @Override
+        public boolean removeAll(IntCollection c) {
+            return removeAll((Collection<Integer>) c);
+        }
+
+        @Override
+        public boolean retainAll(IntCollection c) {
+            return retainAll((Collection<Integer>) c);
+        }
+
+    }
+
+    public static IntCollection wrapInts(Collection<Integer> c) {
+        return new WrappingIntCollection(c);
+    }
+
+    public static class WrappingLongCollection implements LongCollection {
+
+        Collection<Long> backing;
+
+        public WrappingLongCollection(Collection<Long> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public int size() {
+            return backing.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return backing.isEmpty();
+        }
+
+        @Override
+        public boolean contains(Object o) {
+            return false;
+        }
+
+        @Override
+        public boolean contains(long o) {
+            return backing.contains(o);
+        }
+
+        @Override
+        public Object[] toArray() {
+            return backing.toArray();
+        }
+
+        @Override
+        public <T> T[] toArray(T[] a) {
+            return backing.toArray(a);
+        }
+
+        @Override
+        public boolean add(Long aLong) {
+            return false;
+        }
+
+        @Override
+        public boolean add(long e) {
+            return backing.add(e);
+        }
+
+        @Override
+        public boolean remove(Object o) {
+            return backing.remove(o);
+        }
+
+        @Override
+        public boolean containsAll(Collection<?> c) {
+            return backing.containsAll(c);
+        }
+
+        @Override
+        public boolean addAll(Collection<? extends Long> c) {
+            return backing.addAll(c);
+        }
+
+        @Override
+        public boolean removeAll(Collection<?> c) {
+            return backing.removeAll(c);
+        }
+
+        @Override
+        public boolean retainAll(Collection<?> c) {
+            return backing.retainAll(c);
+        }
+
+        @Override
+        public void clear() {
+            backing.clear();
+        }
+
+        @Override
+        public LongIterator iterator() {
+            return FastUtilHackUtil.itrLongWrap(backing);
+        }
+
+        @Override
+        public LongIterator longIterator() {
+            return null;
+        }
+
+        @Override
+        public boolean rem(long key) {
+            return this.remove(key);
+        }
+
+        @Override
+        public long[] toLongArray() {
+            return null;
+        }
+
+        @Override
+        public long[] toLongArray(long[] a) {
+            return toArray(a);
+        }
+
+        @Override
+        public long[] toArray(long[] a) {
+            return ArrayUtils.toPrimitive(backing.toArray(new Long[0]));
+        }
+
+        @Override
+        public boolean addAll(LongCollection c) {
+            return addAll((Collection<Long>) c);
+        }
+
+        @Override
+        public boolean containsAll(LongCollection c) {
+            return containsAll((Collection<Long>) c);
+        }
+
+        @Override
+        public boolean removeAll(LongCollection c) {
+            return removeAll((Collection<Long>) c);
+        }
+
+        @Override
+        public boolean retainAll(LongCollection c) {
+            return retainAll((Collection<Long>) c);
+        }
+
+    }
+
+    public static LongCollection wrapLongs(Collection<Long> c) {
+        return new WrappingLongCollection(c);
+    }
+
+
+    public static class WrappingLongListIterator implements LongListIterator {
+
+        ListIterator<Long> backing;
+
+        public WrappingLongListIterator(ListIterator<Long> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public long previousLong() {
+            return backing.previous();
+        }
+
+        @Override
+        public int back(int n) {
+            return 0;
+        }
+
+        @Override
+        public long nextLong() {
+            return backing.next();
+        }
+
+        @Override
+        public int skip(int n) {
+            return 0;
+        }
+
+        @Override
+        public boolean hasNext() {
+            return backing.hasNext();
+        }
+
+        @Override
+        public Long next() {
+            return null;
+        }
+
+        @Override
+        public boolean hasPrevious() {
+            return backing.hasPrevious();
+        }
+
+        @Override
+        public Long previous() {
+            return null;
+        }
+
+        @Override
+        public int nextIndex() {
+            return backing.nextIndex();
+        }
+
+        @Override
+        public int previousIndex() {
+            return backing.previousIndex();
+        }
+
+        @Override
+        public void add(long k) {
+            backing.add(k);
+        }
+
+        @Override
+        public void remove() {
+            backing.remove();
+        }
+
+        @Override
+        public void set(Long aLong) {
+
+        }
+
+        @Override
+        public void add(Long aLong) {
+
+        }
+
+        @Override
+        public void set(long k) {
+            backing.set(k);
+        }
+    }
+
+    public static class SlimWrappingLongListIterator implements LongListIterator {
+
+        Iterator<Long> backing;
+
+        public SlimWrappingLongListIterator(Iterator<Long> backing) {
+            this.backing = backing;
+        }
+
+        @Override
+        public long previousLong() {
+            throw new IllegalStateException();
+        }
+
+        @Override
+        public int back(int n) {
+            return 0;
+        }
+
+        @Override
+        public long nextLong() {
+            return backing.next();
+        }
+
+        @Override
+        public int skip(int n) {
+            return 0;
+        }
+
+        @Override
+        public boolean hasNext() {
+            return backing.hasNext();
+        }
+
+        @Override
+        public Long next() {
+            return null;
+        }
+
+        @Override
+        public boolean hasPrevious() {
+            throw new IllegalStateException();
+        }
+
+        @Override
+        public Long previous() {
+            return null;
+        }
+
+        @Override
+        public int nextIndex() {
+            throw new IllegalStateException();
+        }
+
+        @Override
+        public int previousIndex() {
+            throw new IllegalStateException();
+        }
+
+        @Override
+        public void add(long k) {
+            throw new IllegalStateException();
+        }
+
+        @Override
+        public void remove() {
+            backing.remove();
+        }
+
+        @Override
+        public void set(Long aLong) {
+
+        }
+
+        @Override
+        public void add(Long aLong) {
+
+        }
+
+        @Override
+        public void set(long k) {
+            throw new IllegalStateException();
+        }
+    }
+
+    public static LongListIterator wrap(ListIterator<Long> c) {
+        return new WrappingLongListIterator(c);
+    }
+
+    public static LongListIterator wrap(Iterator<Long> c) {
+        return new SlimWrappingLongListIterator(c);
+    }
+
+    public static class WrappingByteIterator implements ByteIterator {
+
+        Iterator<Byte> parent;
+
+        public WrappingByteIterator(Iterator<Byte> parent) {
+            this.parent = parent;
+        }
+
+        @Override
+        public boolean hasNext() {
+            return parent.hasNext();
+        }
+
+        @Override
+        public Byte next() {
+            return parent.next();
+        }
+
+        @Override
+        public void remove() {
+            parent.remove();
+        }
+
+        @Override
+        public byte nextByte() {
+            return next();
+        }
+
+        @Override
+        public int skip(int n) {
+            return 0;
+        }
+
+    }
+
+    public static ByteIterator itrByteWrap(Iterator<Byte> backing) {
+        return new WrappingByteIterator(backing);
+    }
+
+    public static ByteIterator itrByteWrap(Iterable<Byte> backing) {
+        return new WrappingByteIterator(backing.iterator());
+    }
+
+    public static IntIterator itrIntWrap(Iterator<Integer> backing) {
+        return new WrappingIntIterator(backing);
+    }
+
+    public static IntIterator itrIntWrap(Iterable<Integer> backing) {
+        return new WrappingIntIterator(backing.iterator());
+    }
+
+    public static LongIterator itrLongWrap(Iterator<Long> backing) {
+        return new WrappingLongIterator(backing);
+    }
+
+    public static LongIterator itrLongWrap(Iterable<Long> backing) {
+        return new WrappingLongIterator(backing.iterator());
+    }
+
+    public static ShortIterator itrShortWrap(Iterator<Short> backing) {
+        return new WrappingShortIterator(backing);
+    }
+
+    public static ShortIterator itrShortWrap(Iterable<Short> backing) {
+        return new WrappingShortIterator(backing.iterator());
+    }
+
+    public static class WrapperObjectIterator<T> implements ObjectIterator<T> {
+
+        Iterator<T> parent;
+
+        public WrapperObjectIterator(Iterator<T> parent) {
+            this.parent = parent;
+        }
+
+        @Override
+        public boolean hasNext() {
+            return parent.hasNext();
+        }
+
+        @Override
+        public T next() {
+            return parent.next();
+        }
+
+        @Override
+        public void remove() {
+            parent.remove();
+        }
+
+        @Override
+        public int skip(int n) {
+            return 0;
+        }
+    }
+
+    public static class IntWrapperEntry<T> implements Entry<T> {
+
+        java.util.Map.Entry<Integer, T> parent;
+
+        public IntWrapperEntry(java.util.Map.Entry<Integer, T> parent) {
+            this.parent = parent;
+        }
+
+        @Override
+        public T getValue() {
+            return parent.getValue();
+        }
+
+        @Override
+        public T setValue(T value) {
+            return parent.setValue(value);
+        }
+
+        @Override
+        public int getIntKey() {
+            return parent.getKey();
+        }
+
+        @Override
+        public Integer getKey() {
+            return parent.getKey();
+        }
+
+    }
+
+    public static class Long2IntWrapperEntry implements Long2IntMap.Entry {
+
+        java.util.Map.Entry<Long, Integer> parent;
+
+        public Long2IntWrapperEntry(java.util.Map.Entry<Long, Integer> parent) {
+            this.parent = parent;
+        }
+
+        @Override
+        public Long getKey() {
+            return null;
+        }
+
+        @Override
+        public long getLongKey() {
+            return parent.getKey();
+        }
+
+        @Override
+        public Integer getValue() {
+            return null;
+        }
+
+        @Override
+        public Integer setValue(Integer value) {
+            return null;
+        }
+
+        @Override
+        public int getIntValue() {
+            return parent.getValue();
+        }
+
+        @Override
+        public int setValue(int value) {
+            return parent.setValue(value);
+        }
+
+
+    }
+
+    public static class WrapperIntEntryObjectIterator<T> implements ObjectIterator<Entry<T>> {
+
+        Iterator<Map.Entry<Integer, T>> parent;
+
+        public WrapperIntEntryObjectIterator(Iterator<Map.Entry<Integer, T>> parent) {
+            this.parent = parent;
+        }
+
+        @Override
+        public boolean hasNext() {
+            return parent.hasNext();
+        }
+
+        @Override
+        public Entry<T> next() {
+            Map.Entry<Integer, T> val = parent.next();
+            if (val == null) return null;
+            return new IntWrapperEntry<T>(val);
+        }
+
+        @Override
+        public void remove() {
+            parent.remove();
+        }
+
+        @Override
+        public int skip(int n) {
+            return 0;
+        }
+    }
+
+    public static <T> ObjectIterator<Entry<T>> intMapItrFake(Map<Integer, T> in) {
+        return new WrapperIntEntryObjectIterator<T>(in.entrySet().iterator());
+    }
+
+    public static <T> ObjectIterator<T> itrWrap(Iterator<T> in) {
+        return new WrapperObjectIterator<T>(in);
+    }
+
+    public static <T> ObjectIterator<T> itrWrap(Iterable<T> in) {
+        return new WrapperObjectIterator<T>(in.iterator());
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Int2ObjectConcurrentHashMap.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Int2ObjectConcurrentHashMap.java
new file mode 100644
index 000000000..ae72eacbb
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Int2ObjectConcurrentHashMap.java
@@ -0,0 +1,114 @@
+package net.himeki.mcmtfabric.parallelised.fastutil;
+
+import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
+import it.unimi.dsi.fastutil.ints.IntSet;
+import it.unimi.dsi.fastutil.objects.ObjectCollection;
+import it.unimi.dsi.fastutil.objects.ObjectSet;
+import org.apache.commons.lang3.NotImplementedException;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+public class Int2ObjectConcurrentHashMap<V> implements Int2ObjectMap<V> {
+
+    Map<Integer, V> backing;
+
+
+    public Int2ObjectConcurrentHashMap() {
+        backing = new ConcurrentHashMap<Integer, V>();
+    }
+
+    @Override
+    public V get(int key) {
+        return backing.get(key);
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return backing.isEmpty();
+    }
+
+    @Override
+    public boolean containsValue(Object value) {
+        return backing.containsValue(value);
+    }
+
+    @Override
+    public void putAll(Map<? extends Integer, ? extends V> m) {
+        backing.putAll(m);
+    }
+
+    @Override
+    public int size() {
+        return backing.size();
+    }
+
+    @Override
+    public void defaultReturnValue(V rv) {
+        throw new NotImplementedException("MCMT - Not implemented");
+    }
+
+    @Override
+    public V defaultReturnValue() {
+        return null;
+    }
+
+    @Override
+    public ObjectSet<Map.Entry<Integer, V>> entrySet() {
+        return null;
+    }
+
+    @Override
+    public ObjectSet<Entry<V>> int2ObjectEntrySet() {
+        return FastUtilHackUtil.entrySetIntWrap(backing);
+    }
+
+
+    @Override
+    public IntSet keySet() {
+        return FastUtilHackUtil.wrapIntSet(backing.keySet());
+    }
+
+    @Override
+    public ObjectCollection<V> values() {
+        return FastUtilHackUtil.wrap(backing.values());
+    }
+
+    @Override
+    public boolean containsKey(int key) {
+        return backing.containsKey(key);
+    }
+
+    @Override
+    public V put(int key, V value) {
+        return backing.put(key, value);
+    }
+
+    @Override
+    public V put(Integer key, V value) {
+        return backing.put(key, value);
+    }
+
+    @Override
+    public V get(Object key) {
+        return null;
+    }
+
+    @Override
+    public boolean containsKey(Object key) {
+        return false;
+    }
+
+    @Override
+    public V remove(Object key) {
+        return null;
+    }
+
+    @Override
+    public V remove(int key) {
+        return backing.remove(key);
+    }
+
+    @Override
+    public void clear() { backing.clear(); }
+}
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2ByteConcurrentHashMap.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2ByteConcurrentHashMap.java
new file mode 100644
index 000000000..1f61dc88c
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2ByteConcurrentHashMap.java
@@ -0,0 +1,125 @@
+package net.himeki.mcmtfabric.parallelised.fastutil;
+
+import it.unimi.dsi.fastutil.bytes.ByteCollection;
+import it.unimi.dsi.fastutil.longs.Long2ByteMap;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import it.unimi.dsi.fastutil.objects.ObjectSet;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+public class Long2ByteConcurrentHashMap implements Long2ByteMap {
+
+    Map<Long, Byte> backing;
+    byte defaultReturn = 0;
+    byte nullKey = 0;
+
+    public Long2ByteConcurrentHashMap() {
+        backing = new ConcurrentHashMap<Long, Byte>();
+    }
+
+    @Override
+    public byte get(long key) {
+        Byte out = backing.get(key);
+        return (out == null && !backing.containsKey(key)) ? defaultReturn : out;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return backing.isEmpty();
+    }
+
+    @Override
+    public boolean containsValue(byte value) {
+        return backing.containsValue(value);
+    }
+
+    @Override
+    public void putAll(Map<? extends Long, ? extends Byte> m) {
+        backing.putAll(m);
+    }
+
+    @Override
+    public int size() {
+        return backing.size();
+    }
+
+    @Override
+    public void clear() {
+
+    }
+
+    @Override
+    public void defaultReturnValue(byte rv) {
+        defaultReturn = rv;
+    }
+
+    @Override
+    public byte defaultReturnValue() {
+        return defaultReturn;
+    }
+
+    @Override
+    public ObjectSet<Map.Entry<Long, Byte>> entrySet() {
+        return null;
+    }
+
+    @Override
+    public ObjectSet<Entry> long2ByteEntrySet() {
+        return FastUtilHackUtil.entrySetLongByteWrap(backing);
+    }
+
+    @Override
+    public LongSet keySet() {
+        return FastUtilHackUtil.wrapLongSet(backing.keySet());
+    }
+
+    @Override
+    public ByteCollection values() {
+        return FastUtilHackUtil.wrapBytes(backing.values());
+    }
+
+    @Override
+    public boolean containsKey(long key) {
+        return backing.containsKey(key);
+    }
+
+    @Override
+    public byte put(long key, byte value) {
+        return put((Long)key, (Byte)value);
+    }
+
+    @Override
+    public Byte put(Long key, Byte value) {
+        Byte out = backing.put(key, value);
+        return (out == null && !backing.containsKey(key)) ? defaultReturn : backing.put(key, value);
+    }
+
+    @Override
+    public Byte get(Object key) {
+        return null;
+    }
+
+    @Override
+    public boolean containsKey(Object key) {
+        return false;
+    }
+
+    @Override
+    public boolean containsValue(Object value) {
+        return false;
+    }
+
+    @Override
+    public Byte remove(Object key) {
+        return null;
+    }
+
+    @Override
+    public byte remove(long key) {
+        Byte out = backing.remove(key);
+        return (out == null && !backing.containsKey(key)) ? defaultReturn : out;
+    }
+
+
+}
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2IntConcurrentHashMap.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2IntConcurrentHashMap.java
new file mode 100644
index 000000000..3f0f103e8
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2IntConcurrentHashMap.java
@@ -0,0 +1,119 @@
+package net.himeki.mcmtfabric.parallelised.fastutil;
+
+import it.unimi.dsi.fastutil.ints.IntCollection;
+import it.unimi.dsi.fastutil.longs.Long2IntMap;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import it.unimi.dsi.fastutil.objects.ObjectSet;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+public class Long2IntConcurrentHashMap implements Long2IntMap {
+
+    public Map<Long, Integer> backing = new ConcurrentHashMap<Long, Integer>();
+    int defaultRV = 0;
+
+    @Override
+    public int put(long key, int value) {
+        return 0;
+    }
+
+    @Override
+    public int get(long key) {
+        if (backing.containsKey(key)) {
+            return backing.get(key);
+        } else return defaultRV;
+    }
+
+    @Override
+    public int remove(long key) {
+        return 0;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return backing.isEmpty();
+    }
+
+    @Override
+    public void putAll(Map<? extends Long, ? extends Integer> m) {
+        backing.putAll(m);
+    }
+
+    @Override
+    public Integer put(Long key, Integer value) {
+        return null;
+    }
+
+    @Override
+    public Integer get(Object key) {
+        return null;
+    }
+
+    @Override
+    public boolean containsKey(Object key) {
+        return false;
+    }
+
+    @Override
+    public boolean containsValue(Object value) {
+        return false;
+    }
+
+    @Override
+    public Integer remove(Object key) {
+        return null;
+    }
+
+    @Override
+    public int size() {
+        return backing.size();
+    }
+
+    @Override
+    public void clear() {
+
+    }
+
+    @Override
+    public void defaultReturnValue(int rv) {
+        defaultRV = rv;
+    }
+
+    @Override
+    public int defaultReturnValue() {
+        return defaultRV;
+    }
+
+    @Override
+    public ObjectSet<Map.Entry<Long, Integer>> entrySet() {
+        return null;
+    }
+
+    @Override
+    public ObjectSet<Entry> long2IntEntrySet() {
+        return null;
+    }
+
+    @Override
+    public LongSet keySet() {
+        return FastUtilHackUtil.wrapLongSet(backing.keySet());
+    }
+
+    @Override
+    public IntCollection values() {
+        return FastUtilHackUtil.wrapInts(backing.values());
+    }
+
+    @Override
+    public boolean containsKey(long key) {
+        return backing.containsKey(key);
+    }
+
+    @Override
+    public boolean containsValue(int value) {
+        return backing.containsValue(value);
+    }
+
+
+}
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2IntConcurrentNonLinkedOpenMap.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2IntConcurrentNonLinkedOpenMap.java
new file mode 100644
index 000000000..1977a40ce
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2IntConcurrentNonLinkedOpenMap.java
@@ -0,0 +1,373 @@
+package net.himeki.mcmtfabric.parallelised.fastutil;
+
+import it.unimi.dsi.fastutil.Hash;
+import it.unimi.dsi.fastutil.ints.IntCollection;
+import it.unimi.dsi.fastutil.longs.*;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+@SuppressWarnings("deprecation")
+public class Long2IntConcurrentNonLinkedOpenMap extends Long2IntLinkedOpenHashMap {
+
+    /**
+     *
+     */
+    private static final long serialVersionUID = -2082212127278131631L;
+
+    public Map<Long, Integer> backing = new ConcurrentHashMap<Long, Integer>();
+
+    public Long2IntConcurrentNonLinkedOpenMap(final int expected, final float f) {
+
+    }
+
+    /**
+     * Creates a new hash map with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor.
+     *
+     * @param expected the expected number of elements in the hash map.
+     */
+    public Long2IntConcurrentNonLinkedOpenMap(final int expected) {
+    }
+
+    /**
+     * Creates a new hash map with initial expected
+     * {@link Hash#DEFAULT_INITIAL_SIZE} entries and
+     * {@link Hash#DEFAULT_LOAD_FACTOR} as load factor.
+     */
+    public Long2IntConcurrentNonLinkedOpenMap() {
+    }
+
+    /**
+     * Creates a new hash map copying a given one.
+     *
+     * @param m a {@link Map} to be copied into the new hash map.
+     * @param f the load factor.
+     */
+    public Long2IntConcurrentNonLinkedOpenMap(final Map<? extends Long, ? extends Integer> m, final float f) {
+        putAll(m);
+    }
+
+    /**
+     * Creates a new hash map with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor
+     * copying a given one.
+     *
+     * @param m a {@link Map} to be copied into the new hash map.
+     */
+    public Long2IntConcurrentNonLinkedOpenMap(final Map<? extends Long, ? extends Integer> m) {
+        this(m, DEFAULT_LOAD_FACTOR);
+    }
+
+    /**
+     * Creates a new hash map copying a given type-specific one.
+     *
+     * @param m a type-specific map to be copied into the new hash map.
+     * @param f the load factor.
+     */
+    public Long2IntConcurrentNonLinkedOpenMap(final Long2IntMap m, final float f) {
+        this(m.size(), f);
+        putAll(m);
+    }
+
+    /**
+     * Creates a new hash map with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor
+     * copying a given type-specific one.
+     *
+     * @param m a type-specific map to be copied into the new hash map.
+     */
+    public Long2IntConcurrentNonLinkedOpenMap(final Long2IntMap m) {
+        this(m, DEFAULT_LOAD_FACTOR);
+    }
+
+    /**
+     * Creates a new hash map using the elements of two parallel arrays.
+     *
+     * @param k the array of keys of the new hash map.
+     * @param v the array of corresponding values in the new hash map.
+     * @param f the load factor.
+     * @throws IllegalArgumentException if {@code k} and {@code v} have different
+     *                                  lengths.
+     */
+    public Long2IntConcurrentNonLinkedOpenMap(final long[] k, final int[] v, final float f) {
+        if (k.length != v.length)
+            throw new IllegalArgumentException(
+                    "The key array and the value array have different lengths (" + k.length + " and " + v.length + ")");
+        for (int i = 0; i < k.length; i++)
+            this.put(k[i], v[i]);
+    }
+
+    /**
+     * Creates a new hash map with {@link Hash#DEFAULT_LOAD_FACTOR} as load factor
+     * using the elements of two parallel arrays.
+     *
+     * @param k the array of keys of the new hash map.
+     * @param v the array of corresponding values in the new hash map.
+     * @throws IllegalArgumentException if {@code k} and {@code v} have different
+     *                                  lengths.
+     */
+    public Long2IntConcurrentNonLinkedOpenMap(final long[] k, final int[] v) {
+        this(k, v, DEFAULT_LOAD_FACTOR);
+    }
+
+    public void putAll(Map<? extends Long, ? extends Integer> m) {
+        backing.putAll(m);
+    }
+
+    public int put(final long k, final int v) {
+        Integer out = backing.put(k, v);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    public int addTo(final long k, final int incr) {
+        Integer out =  backing.put(k, this.get(k)+incr);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    public int remove(final long k) {
+        Integer out = backing.remove(k);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    public int removeFirstInt() {
+        Integer out = this.remove(backing.keySet().stream().findAny().get());
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    public int removeLastInt() {
+        Integer out = this.remove(backing.keySet().stream().findAny().get());
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+
+    public int getAndMoveToFirst(final long k) {
+        Integer out = backing.get(k);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    public int getAndMoveToLast(final long k) {
+        Integer out = backing.get(k);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    public int putAndMoveToFirst(final long k, final int v) {
+        Integer out =  backing.put(k, v);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    public int putAndMoveToLast(final long k, final int v) {
+        Integer out =  backing.put(k, v);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    public int get(final long k) {
+        Integer out =  backing.get(k);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    public boolean containsKey(final long k) {
+        return backing.containsKey(k);
+    }
+
+    public boolean containsValue(final int v) {
+        return backing.containsValue(v);
+    }
+
+    public int getOrDefault(final long k, final int defaultValue) {
+        Integer out =  backing.getOrDefault(k, defaultValue);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    public int putIfAbsent(final long k, final int v) {
+        Integer out =  backing.putIfAbsent(k, v);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+
+    public boolean remove(final long k, final int v) {
+        return backing.remove(k, v);
+    }
+
+
+    public boolean replace(final long k, final int oldValue, final int v) {
+        return  backing.replace(k, oldValue, v);
+    }
+
+
+    public int replace(final long k, final int v) {
+        Integer out = backing.replace(k, v);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+
+    public int computeIfAbsent(final long k, final java.util.function.LongToIntFunction mappingFunction) {
+        Integer out =  backing.computeIfAbsent(k, (l) -> mappingFunction.applyAsInt(l));
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+
+    public int computeIfAbsentNullable(final long k,
+                                       final java.util.function.LongFunction<? extends Integer> mappingFunction) {
+        Integer out =  backing.computeIfAbsent(k, (l) -> mappingFunction.apply(l));
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+
+    public int computeIfPresent(final long k,
+                                final java.util.function.BiFunction<? super Long, ? super Integer, ? extends Integer> remappingFunction) {
+        if (this.containsKey(k)) {
+            Integer out =  backing.put(k, remappingFunction.apply(k, backing.get(k)));
+            if (out == null) {
+                return defRetValue;
+            }
+            return out;
+        }
+        return defaultReturnValue();
+
+    }
+
+    public int compute(final long k,
+                       final java.util.function.BiFunction<? super Long, ? super Integer, ? extends Integer> remappingFunction) {
+        Integer out = backing.compute(k, remappingFunction);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    public int merge(final long k, final int v,
+                     final java.util.function.BiFunction<? super Integer, ? super Integer, ? extends Integer> remappingFunction) {
+        Integer out =  backing.merge(k, v, remappingFunction);
+        if (out == null) {
+            return defRetValue;
+        }
+        return out;
+    }
+
+    @Override
+    public void clear() {
+        backing.clear();
+    }
+
+    @Override
+    public int size() {
+        return backing.size();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return backing.isEmpty();
+    }
+
+    @Override
+    public long firstLongKey() {
+        return backing.keySet().stream().findAny().get();
+    }
+
+    @Override
+    public long lastLongKey() {
+        return backing.keySet().stream().findAny().get();
+    }
+
+    @Override
+    public Long2IntSortedMap tailMap(long from) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public Long2IntSortedMap headMap(long to) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public Long2IntSortedMap subMap(long from, long to) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public LongComparator comparator() {
+        return null;
+    }
+
+
+    @Override
+    public FastSortedEntrySet long2IntEntrySet() {
+        //TODO implement
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public LongSortedSet keySet() {
+        return FastUtilHackUtil.wrapLongSortedSet(backing.keySet());
+    }
+
+
+    @Override
+    public IntCollection values() {
+        return FastUtilHackUtil.wrapInts(backing.values());
+    }
+
+    public boolean trim() {
+        return true;
+    }
+
+    public boolean trim(final int n) {
+        return true;
+    }
+
+
+    @Override
+    public Long2IntConcurrentNonLinkedOpenMap clone() {
+        return new Long2IntConcurrentNonLinkedOpenMap(backing);
+    }
+
+    @Override
+    public int hashCode() {
+        return backing.hashCode();
+    }
+
+
+}
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2LongConcurrentHashMap.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2LongConcurrentHashMap.java
new file mode 100644
index 000000000..d3b5d43de
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2LongConcurrentHashMap.java
@@ -0,0 +1,127 @@
+package net.himeki.mcmtfabric.parallelised.fastutil;
+
+import it.unimi.dsi.fastutil.longs.Long2LongMap;
+import it.unimi.dsi.fastutil.longs.LongCollection;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import it.unimi.dsi.fastutil.objects.ObjectSet;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+
+public class Long2LongConcurrentHashMap implements Long2LongMap {
+
+    public Map<Long, Long> backing = new ConcurrentHashMap<Long, Long>();
+    long defaultRV = 0;
+
+    public Long2LongConcurrentHashMap(long defaultRV) {
+        this.defaultRV = defaultRV;
+    }
+
+    @Override
+    public long get(long key) {
+        if (backing.containsKey(key)) {
+            return backing.get(key);
+        } else return defaultRV;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return backing.isEmpty();
+    }
+
+    @Override
+    public long put(final long key, final long val) {
+        backing.put(key,val);
+        return val;
+    }
+
+    @Override
+    public Long put(final Long key, final Long val) {
+        backing.put(key,val);
+        return val;
+    }
+
+    @Override
+    public Long get(Object key) {
+        return null;
+    }
+
+    @Override
+    public boolean containsKey(Object key) {
+        return false;
+    }
+
+    @Override
+    public boolean containsValue(Object value) {
+        return false;
+    }
+
+    @Override
+    public Long remove(Object key) {
+        return null;
+    }
+
+    @Override
+    public long remove(final long key) {
+        return backing.remove(key);
+    }
+
+    @Override
+    public void putAll(Map<? extends Long, ? extends Long> m) {
+        backing.putAll(m);
+    }
+
+    @Override
+    public int size() {
+        return backing.size();
+    }
+
+    @Override
+    public void clear() {
+
+    }
+
+    @Override
+    public void defaultReturnValue(long rv) {
+        defaultRV = rv;
+    }
+
+    @Override
+    public long defaultReturnValue() {
+        return defaultRV;
+    }
+
+    @Override
+    public ObjectSet<Map.Entry<Long, Long>> entrySet() {
+        return null;
+    }
+
+    @Override
+    public ObjectSet<Entry> long2LongEntrySet() {
+        return FastUtilHackUtil.entrySetLongLongWrap(backing);
+    }
+
+
+    @Override
+    public LongSet keySet() {
+        return FastUtilHackUtil.wrapLongSet(backing.keySet());
+    }
+
+    @Override
+    public LongCollection values() {
+        return FastUtilHackUtil.wrapLongs(backing.values());
+    }
+
+    @Override
+    public boolean containsKey(long key) {
+        return backing.containsKey(key);
+    }
+
+    @Override
+    public boolean containsValue(long value) {
+        return backing.containsValue(value);
+    }
+
+
+}
\ No newline at end of file
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2ObjectConcurrentHashMap.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2ObjectConcurrentHashMap.java
new file mode 100644
index 000000000..16f9677a7
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2ObjectConcurrentHashMap.java
@@ -0,0 +1,122 @@
+package net.himeki.mcmtfabric.parallelised.fastutil;
+
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import it.unimi.dsi.fastutil.objects.ObjectCollection;
+import it.unimi.dsi.fastutil.objects.ObjectSet;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+public class Long2ObjectConcurrentHashMap<V> implements Long2ObjectMap<V> {
+
+    Map<Long, V> backing;
+    V defaultReturn = null;
+
+    public Long2ObjectConcurrentHashMap() {
+        backing = new ConcurrentHashMap<Long, V>();
+    }
+
+    public Long2ObjectConcurrentHashMap(int e) {
+        backing = new ConcurrentHashMap<Long, V>(e);
+    }
+
+    @Override
+    public V get(long key) {
+        V out = backing.get(key);
+        return (out == null && !backing.containsKey(key)) ? defaultReturn : out;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return backing.isEmpty();
+    }
+
+    @Override
+    public boolean containsValue(Object value) {
+        return backing.containsValue(value);
+    }
+
+    @Override
+    public void putAll(Map<? extends Long, ? extends V> m) {
+        backing.putAll(m);
+    }
+
+    @Override
+    public int size() {
+        return backing.size();
+    }
+
+    @Override
+    public void clear() {
+
+    }
+
+    @Override
+    public void defaultReturnValue(V rv) {
+        defaultReturn = rv;
+    }
+
+    @Override
+    public V defaultReturnValue() {
+        return defaultReturn;
+    }
+
+    @Override
+    public ObjectSet<Map.Entry<Long, V>> entrySet() {
+        return null;
+    }
+
+    @Override
+    public ObjectSet<Entry<V>> long2ObjectEntrySet() {
+        return FastUtilHackUtil.entrySetLongWrap(backing);
+    }
+
+
+    @Override
+    public LongSet keySet() {
+        return FastUtilHackUtil.wrapLongSet(backing.keySet());
+    }
+
+    @Override
+    public ObjectCollection<V> values() {
+        return FastUtilHackUtil.wrap(backing.values());
+    }
+
+    @Override
+    public boolean containsKey(long key) {
+        return backing.containsKey(key);
+    }
+
+    @Override
+    public V put(long key, V value) {
+        return put((Long)key, value);
+    }
+
+    @Override
+    public V put(Long key, V value) {
+        V out = backing.put(key, value);
+        return (out == null && !backing.containsKey(key)) ? defaultReturn : backing.put(key, value);
+    }
+
+    @Override
+    public V get(Object key) {
+        return null;
+    }
+
+    @Override
+    public boolean containsKey(Object key) {
+        return false;
+    }
+
+    @Override
+    public V remove(Object key) {
+        return null;
+    }
+
+    @Override
+    public V remove(long key) {
+        V out = backing.remove(key);
+        return (out == null && !backing.containsKey(key)) ? defaultReturn : out;
+    }
+}
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2ObjectOpenConcurrentHashMap.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2ObjectOpenConcurrentHashMap.java
new file mode 100644
index 000000000..2f6c6b63c
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/Long2ObjectOpenConcurrentHashMap.java
@@ -0,0 +1,225 @@
+package net.himeki.mcmtfabric.parallelised.fastutil;
+
+import it.unimi.dsi.fastutil.longs.Long2ObjectFunction;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import it.unimi.dsi.fastutil.objects.ObjectCollection;
+import it.unimi.dsi.fastutil.objects.ObjectSet;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.function.Function;
+
+import static it.unimi.dsi.fastutil.HashCommon.nextPowerOfTwo;
+
+public class Long2ObjectOpenConcurrentHashMap<V> extends Long2ObjectOpenHashMap<V> {
+
+    /**
+     *
+     */
+    private static final long serialVersionUID = -121514116954680057L;
+
+    Map<Long, V> backing;
+    V defaultReturn = null;
+
+    public Long2ObjectOpenConcurrentHashMap() {
+        backing = new ConcurrentHashMap<Long, V>();
+    }
+
+    public Long2ObjectOpenConcurrentHashMap(int e){
+        final long s = Math.max(2, nextPowerOfTwo( (long)Math.ceil( e / .75f ) ) );
+        backing = new ConcurrentHashMap<>();
+    }
+
+    @Override
+    public V get(long key) {
+        V out = backing.get(key);
+        return (out == null && !backing.containsKey(key)) ? defaultReturn : out;
+    }
+
+    @Override
+    public V get(Object key) {
+        V out = backing.get(key);
+        return (out == null && !backing.containsKey(key)) ? defaultReturn : out;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return backing.isEmpty();
+    }
+
+    @Override
+    public boolean containsValue(Object value) {
+        return backing.containsValue(value);
+    }
+
+    @Override
+    public void putAll(Map<? extends Long, ? extends V> m) {
+        backing.putAll(m);
+    }
+
+    @Override
+    public int size() {
+        return backing.size();
+    }
+
+    @Override
+    public void defaultReturnValue(V rv) {
+        defaultReturn = rv;
+    }
+
+    @Override
+    public V defaultReturnValue() {
+        return defaultReturn;
+    }
+
+    @Override
+    public FastEntrySet<V> long2ObjectEntrySet() {
+        return FastUtilHackUtil.entrySetLongWrapFast(backing);
+    }
+
+
+    @Override
+    public LongSet keySet() {
+        return FastUtilHackUtil.wrapLongSet(backing.keySet());
+    }
+
+    @Override
+    public ObjectCollection<V> values() {
+        return FastUtilHackUtil.wrap(backing.values());
+    }
+
+    @Override
+    public boolean containsKey(long key) {
+        return backing.containsKey(key);
+    }
+
+    @Override
+    public V put(long key, V value) {
+        return put((Long)key, value);
+    }
+
+    @Override
+    public V put(Long key, V value) {
+        V out = backing.put(key, value);
+        return (out == null && !backing.containsKey(key)) ? defaultReturn : backing.put(key, value);
+    }
+
+    @Override
+    public V remove(long key) {
+        V out = backing.remove(key);
+        return (out == null && !backing.containsKey(key)) ? defaultReturn : out;
+    }
+
+    @Override
+    public boolean trim() { return true; }
+
+    @Override
+    public boolean trim(final int n) { return true; }
+
+
+    public boolean replace(final long k, final V oldValue, final V v) {
+        return backing.replace(k, oldValue, v);
+    }
+
+    public V replace(final long k, final V v) {
+        return backing.replace(k, v);
+    }
+
+    @Override
+    public boolean replace(final Long k, final V oldValue, final V v) {
+        return backing.replace(k, oldValue, v);
+    }
+
+    @Override
+    public V replace(final Long k, final V v) {
+        return backing.replace(k, v);
+    }
+
+    public boolean remove(final long k, final Object v) {
+        return backing.remove(k, v);
+    }
+
+    public V putIfAbsent(final long k, final V v) {
+        return backing.putIfAbsent(k, v);
+    }
+
+    @Override
+    public V putIfAbsent(final Long k, final V v) {
+        return backing.putIfAbsent(k, v);
+    }
+
+    public V merge(final long k, final V v, final java.util.function.BiFunction<? super V, ? super V, ? extends V> remappingFunction) {
+        return backing.merge(k, v, remappingFunction);
+    }
+
+    @Override
+    public V merge(Long k, final V v, final java.util.function.BiFunction<? super V, ? super V, ? extends V> remappingFunction) {
+        return backing.merge(k, v, remappingFunction);
+    }
+
+    @Override
+    public int hashCode() {
+        return backing.hashCode();
+    }
+
+    public V getOrDefault(final long k, final V defaultValue) {
+        return backing.getOrDefault(k, defaultValue);
+    }
+
+    @Override
+    public V getOrDefault(Object k, final V defaultValue) {
+        return backing.getOrDefault(k, defaultValue);
+    }
+
+    public V computeIfPresent(final long k, final java.util.function.BiFunction<? super Long, ? super V, ? extends V> remappingFunction) {
+        return backing.computeIfPresent(k, remappingFunction);
+    }
+
+    @Override
+    public V computeIfPresent(final Long k, final java.util.function.BiFunction<? super Long, ? super V, ? extends V> remappingFunction) {
+        return backing.computeIfPresent(k, remappingFunction);
+    }
+
+    public V computeIfAbsent(final long k, final java.util.function.LongFunction<? extends V> mappingFunction) {
+        return backing.computeIfAbsent(k, (llong) -> mappingFunction.apply(llong));
+    }
+
+    public V computeIfAbsent(final Long k, final java.util.function.LongFunction<? extends V> mappingFunction) {
+        return backing.computeIfAbsent(k, (llong) -> mappingFunction.apply(llong));
+    }
+
+    public V compute(final long k, final java.util.function.BiFunction<? super Long, ? super V, ? extends V> remappingFunction) {
+        return backing.compute(k, remappingFunction);
+    }
+
+    @Override
+    public V compute(final Long k, final java.util.function.BiFunction<? super Long, ? super V, ? extends V> remappingFunction) {
+        return backing.compute(k, remappingFunction);
+    }
+
+    @Override
+    public Long2ObjectOpenHashMap<V> clone() {
+        throw new IllegalArgumentException();
+    }
+
+    public void clear() {
+        backing.clear();
+    }
+
+    @Override
+    public ObjectSet<Map.Entry<Long, V>> entrySet() {
+        return new FastUtilHackUtil.ConvertingObjectSet<java.util.Map.Entry<Long, V>, java.util.Map.Entry<Long, V>>(backing.entrySet(), Function.identity(), Function.identity());
+    }
+
+    @Override
+    public V remove(Object key) {
+        return backing.remove(key);
+    }
+
+    @Override
+    public boolean remove(Object key, Object value) {
+        return backing.remove(key, value);
+    }
+
+}
\ No newline at end of file
diff --git a/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/sync/SyncLongLinkedOpenHashSet.java b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/sync/SyncLongLinkedOpenHashSet.java
new file mode 100644
index 000000000..565dc74cb
--- /dev/null
+++ b/src/main/java/net/himeki/mcmtfabric/parallelised/fastutil/sync/SyncLongLinkedOpenHashSet.java
@@ -0,0 +1,197 @@
+package net.himeki.mcmtfabric.parallelised.fastutil.sync;
+
+import java.util.Collection;
+import java.util.Iterator;
+
+import it.unimi.dsi.fastutil.longs.LongArrays;
+import it.unimi.dsi.fastutil.longs.LongCollection;
+import it.unimi.dsi.fastutil.longs.LongComparator;
+import it.unimi.dsi.fastutil.longs.LongIterator;
+import it.unimi.dsi.fastutil.longs.LongIterators;
+import it.unimi.dsi.fastutil.longs.LongLinkedOpenHashSet;
+import it.unimi.dsi.fastutil.longs.LongListIterator;
+import it.unimi.dsi.fastutil.longs.LongSortedSet;
+
+public class SyncLongLinkedOpenHashSet extends LongLinkedOpenHashSet {
+
+    private static final long serialVersionUID = -5532128240738069111L;
+
+    public SyncLongLinkedOpenHashSet() {
+        super();
+    }
+
+    public SyncLongLinkedOpenHashSet(final int initial) {
+        super(initial);
+    }
+
+    public SyncLongLinkedOpenHashSet(final int initial, final float dnc) {
+        this(initial);
+    }
+
+    public SyncLongLinkedOpenHashSet(final LongCollection c) {
+        this(c.size());
+        addAll(c);
+    }
+
+    public SyncLongLinkedOpenHashSet(final LongCollection c, final float f) {
+        this(c.size(), f);
+        addAll(c);
+    }
+
+    public SyncLongLinkedOpenHashSet(final LongIterator i, final float f) {
+        this(16, f);
+        while (i.hasNext())
+            add(i.nextLong());
+    }
+
+    public SyncLongLinkedOpenHashSet(final LongIterator i) {
+        this(i, -1);
+    }
+
+    public SyncLongLinkedOpenHashSet(final Iterator<?> i, final float f) {
+        this(LongIterators.asLongIterator(i), f);
+    }
+
+    public SyncLongLinkedOpenHashSet(final Iterator<?> i) {
+        this(LongIterators.asLongIterator(i));
+    }
+
+    public SyncLongLinkedOpenHashSet(final long[] a, final int offset, final int length, final float f) {
+        this(length < 0 ? 0 : length, f);
+        LongArrays.ensureOffsetLength(a, offset, length);
+        for (int i = 0; i < length; i++)
+            add(a[offset + i]);
+    }
+
+    public SyncLongLinkedOpenHashSet(final long[] a, final int offset, final int length) {
+        this(a, offset, length, DEFAULT_LOAD_FACTOR);
+    }
+
+    public SyncLongLinkedOpenHashSet(final long[] a, final float f) {
+        this(a, 0, a.length, f);
+    }
+
+    public SyncLongLinkedOpenHashSet(final long[] a) {
+        this(a, -1);
+    }
+
+    @Override
+    public synchronized boolean add(final long k) {
+        return super.add(k);
+    }
+
+    @Override
+    public synchronized boolean addAll(LongCollection c) {
+        return super.addAll(c);
+    }
+
+    @Override
+    public synchronized boolean addAll(Collection<? extends Long> c) {
+        return super.addAll(c);
+    }
+
+    @Override
+    public synchronized boolean addAndMoveToFirst(final long k) {
+        return super.addAndMoveToFirst(k);
+    }
+
+    @Override
+    public synchronized boolean addAndMoveToLast(final long k) {
+        return super.addAndMoveToFirst(k);
+    }
+
+    @Override
+    public synchronized void clear() {
+        super.clear();
+    }
+
+    @Override
+    public synchronized LongLinkedOpenHashSet clone() {
+        return new SyncLongLinkedOpenHashSet(this);
+    }
+
+    @Override
+    public synchronized LongComparator comparator() {
+        return super.comparator();
+    }
+
+    @Override
+    public synchronized boolean contains(final long k) {
+        return super.contains(k);
+    }
+
+    @Override
+    public synchronized long firstLong() {
+        return super.firstLong();
+    }
+
+    @Override
+    public synchronized int hashCode() {
+        return super.hashCode();
+    }
+
+    @Override
+    public synchronized LongSortedSet headSet(long to) {
+        return super.headSet(to);
+    }
+
+    @Override
+    public synchronized boolean isEmpty() {
+        return super.isEmpty();
+    }
+
+    @Override
+    public synchronized LongListIterator iterator() {
+        return super.iterator();
+    }
+
+    @Override
+    public synchronized LongListIterator iterator(long from) {
+        return super.iterator(from);
+    }
+
+    @Override
+    public synchronized long lastLong() {
+        return super.lastLong();
+    }
+
+    @Override
+    public synchronized boolean remove(final long k) {
+        return super.remove(k);
+    }
+
+    @Override
+    public synchronized long removeFirstLong() {
+        return super.removeFirstLong();
+    }
+
+    @Override
+    public synchronized long removeLastLong() {
+        return super.removeLastLong();
+    }
+
+    @Override
+    public synchronized int size() {
+        return super.size();
+    }
+
+    @Override
+    public synchronized LongSortedSet subSet(long from, long to) {
+        return super.subSet(from, to);
+    }
+
+    @Override
+    public synchronized LongSortedSet tailSet(long from) {
+        return super.tailSet(from);
+    }
+
+    @Override
+    public synchronized boolean trim() {
+        return super.trim();
+    }
+
+    @Override
+    public synchronized boolean trim(final int n) {
+        return super.trim(n);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java
index 4060fd274..3fdccd8ad 100644
--- a/src/main/java/net/minecraft/server/Chunk.java
+++ b/src/main/java/net/minecraft/server/Chunk.java
@@ -15,6 +15,7 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Random;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentLinkedQueue;
 import javax.annotation.Nullable;
 import org.apache.logging.log4j.LogManager;
@@ -45,7 +46,8 @@ public class Chunk {
     // Paper start
     public final co.aikar.util.Counter<String> entityCounts = new co.aikar.util.Counter<>();
     public final co.aikar.util.Counter<String> tileEntityCounts = new co.aikar.util.Counter<>();
-    private class TileEntityHashMap extends java.util.HashMap<BlockPosition, TileEntity> {
+    //M2ke4U -- HashMap -> ConcurrentHashMap
+    private class TileEntityHashMap extends ConcurrentHashMap<BlockPosition, TileEntity> {
         @Override
         public TileEntity put(BlockPosition key, TileEntity value) {
             TileEntity replaced = super.put(key, value);
@@ -716,7 +718,9 @@ public class Chunk {
         {
             if ( creatureType.a().isAssignableFrom( entity.getClass() ) )
             {
-                this.entityCount.adjustOrPutValue( creatureType.a(), 1, 1 );
+                synchronized (this){
+                    this.entityCount.adjustOrPutValue( creatureType.a(), 1, 1 );
+                }
             }
         }
         // Spigot end
@@ -762,7 +766,9 @@ public class Chunk {
         {
             if ( creatureType.a().isAssignableFrom( entity.getClass() ) )
             {
-                this.entityCount.adjustValue( creatureType.a(), -1 );
+                synchronized (this){
+                    this.entityCount.adjustValue( creatureType.a(), -1 );
+                }
             }
         }
         // Spigot end
diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index ad5485908..b5ed318c5 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -14,6 +14,7 @@ import java.util.List;
 import java.util.Set;
 import javax.annotation.Nullable;
 import com.destroystokyo.paper.exception.ServerInternalException;
+import net.himeki.mcmtfabric.parallelised.fastutil.Long2ObjectOpenConcurrentHashMap;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -25,7 +26,7 @@ import org.bukkit.event.world.ChunkUnloadEvent;
 public class ChunkProviderServer implements IChunkProvider {
 
     private static final Logger a = LogManager.getLogger();
-    public final Set<Long> unloadQueue = Sets.newHashSet();
+    public final Set<Long> unloadQueue = Sets.newConcurrentHashSet(); //M2ke4U thread safe fix
     public final ChunkGenerator chunkGenerator;
     private final IChunkLoader chunkLoader;
     // Paper start - chunk save stats
@@ -35,7 +36,7 @@ public class ChunkProviderServer implements IChunkProvider {
     // Paper end
     // Paper start
     protected Chunk lastChunkByPos = null;
-    public Long2ObjectOpenHashMap<Chunk> chunks = new Long2ObjectOpenHashMap<Chunk>(8192) {
+    public Long2ObjectOpenHashMap<Chunk> chunks = new Long2ObjectOpenConcurrentHashMap<Chunk>(8192) {
 
         @Override
         public Chunk get(long key) {
@@ -75,14 +76,9 @@ public class ChunkProviderServer implements IChunkProvider {
     }
 
     public void b() {
-        ObjectIterator objectiterator = this.chunks.values().iterator();
-
-        while (objectiterator.hasNext()) {
-            Chunk chunk = (Chunk) objectiterator.next();
-
+        for (Chunk chunk : this.chunks.values()) {
             this.unload(chunk);
         }
-
     }
 
     // Paper start
diff --git a/src/main/java/net/minecraft/server/CombatTracker.java b/src/main/java/net/minecraft/server/CombatTracker.java
index bddd66e79..4dca101f6 100644
--- a/src/main/java/net/minecraft/server/CombatTracker.java
+++ b/src/main/java/net/minecraft/server/CombatTracker.java
@@ -1,13 +1,13 @@
 package net.minecraft.server;
 
-import com.google.common.collect.Lists;
+import org.threadly.concurrent.collections.ConcurrentArrayList;
 import java.util.Iterator;
 import java.util.List;
 import javax.annotation.Nullable;
 
 public class CombatTracker {
 
-    private final List<CombatEntry> a = Lists.newArrayList();
+    private final List<CombatEntry> a = new ConcurrentArrayList<>();
     private final EntityLiving b;
     private int c;
     private int d;
diff --git a/src/main/java/net/minecraft/server/Container.java b/src/main/java/net/minecraft/server/Container.java
index 3a488ce20..2adc4201c 100644
--- a/src/main/java/net/minecraft/server/Container.java
+++ b/src/main/java/net/minecraft/server/Container.java
@@ -25,9 +25,9 @@ public abstract class Container {
     public int windowId;
     private int dragType = -1;
     private int g;
-    private final Set<Slot> h = Sets.newHashSet();
+    private final Set<Slot> h = Sets.newConcurrentHashSet();
     protected List<ICrafting> listeners = Lists.newArrayList();
-    private final Set<EntityHuman> i = Sets.newHashSet();
+    private final Set<EntityHuman> i = Sets.newConcurrentHashSet();
     private int tickCount; // Spigot
 
     // CraftBukkit start
diff --git a/src/main/java/net/minecraft/server/EntityLiving.java b/src/main/java/net/minecraft/server/EntityLiving.java
index 82c3a84ed..c04d1f47a 100644
--- a/src/main/java/net/minecraft/server/EntityLiving.java
+++ b/src/main/java/net/minecraft/server/EntityLiving.java
@@ -33,6 +33,7 @@ import org.bukkit.event.player.PlayerItemConsumeEvent;
 // CraftBukkit end
 
 import co.aikar.timings.MinecraftTimings; // Paper
+import org.threadly.concurrent.collections.ConcurrentArrayList;
 
 public abstract class EntityLiving extends Entity {
 
@@ -46,7 +47,7 @@ public abstract class EntityLiving extends Entity {
     private static final DataWatcherObject<Integer> br = DataWatcher.a(EntityLiving.class, DataWatcherRegistry.b);
     private AttributeMapBase attributeMap;
     public CombatTracker combatTracker = new CombatTracker(this);
-    public final Map<MobEffectList, MobEffect> effects = Maps.newHashMap();
+    public final Map<MobEffectList, MobEffect> effects = Maps.newConcurrentMap();
     private final NonNullList<ItemStack> bv;
     private final NonNullList<ItemStack> bw;
     public boolean au;
@@ -113,7 +114,7 @@ public abstract class EntityLiving extends Entity {
     public int expToDrop;
     public int maxAirTicks = 300;
     boolean forceDrops;
-    ArrayList<org.bukkit.inventory.ItemStack> drops = new ArrayList<org.bukkit.inventory.ItemStack>();
+    ArrayList<org.bukkit.inventory.ItemStack> drops = new ConcurrentArrayList<>();
     public org.bukkit.craftbukkit.attribute.CraftAttributeMap craftAttributes;
     public boolean collides = true;
     public boolean canPickUpLoot;
diff --git a/src/main/java/net/minecraft/server/EntityPlayer.java b/src/main/java/net/minecraft/server/EntityPlayer.java
index cb2c459ae..02fbd1642 100644
--- a/src/main/java/net/minecraft/server/EntityPlayer.java
+++ b/src/main/java/net/minecraft/server/EntityPlayer.java
@@ -9,6 +9,7 @@ import java.util.Collection;
 import java.util.Deque; // Paper
 import java.util.Iterator;
 import java.util.List;
+import java.util.concurrent.ConcurrentLinkedDeque;
 import javax.annotation.Nullable;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -40,7 +41,7 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
     public final PlayerInteractManager playerInteractManager;
     public double d;
     public double e;
-    public final Deque<Integer> removeQueue = new ArrayDeque<>(); // Paper
+    public final Deque<Integer> removeQueue = new ConcurrentLinkedDeque<>(); //M2ke4U
     private final AdvancementDataPlayer bY;
     private final ServerStatisticManager bZ;
     private float ca = Float.MIN_VALUE;
diff --git a/src/main/java/net/minecraft/server/IntHashMap.java b/src/main/java/net/minecraft/server/IntHashMap.java
new file mode 100644
index 000000000..5ed72b602
--- /dev/null
+++ b/src/main/java/net/minecraft/server/IntHashMap.java
@@ -0,0 +1,197 @@
+package net.minecraft.server;
+
+import javax.annotation.Nullable;
+
+public class IntHashMap<V> {
+    private transient IntHashMapEntry<V>[] a = new IntHashMapEntry[16];
+    private transient int b;
+    private int c = 12;
+    private final float d = 0.75F;
+
+    private static int g(int var0) {
+        var0 ^= var0 >>> 20 ^ var0 >>> 12;
+        return var0 ^ var0 >>> 7 ^ var0 >>> 4;
+    }
+
+    private static int a(int var0, int var1) {
+        return var0 & var1 - 1;
+    }
+
+    @Nullable
+    public synchronized V get(int var1) {
+        int var2 = g(var1);
+
+        for(IntHashMapEntry var3 = this.a[a(var2, this.a.length)]; var3 != null; var3 = var3.c) {
+            if (var3.a == var1) {
+                return (V) var3.b;
+            }
+        }
+
+        return null;
+    }
+
+    public synchronized boolean b(int var1) {
+        return this.c(var1) != null;
+    }
+
+    @Nullable
+    final IntHashMapEntry<V> c(int var1) {
+        int var2 = g(var1);
+
+        for(IntHashMapEntry var3 = this.a[a(var2, this.a.length)]; var3 != null; var3 = var3.c) {
+            if (var3.a == var1) {
+                return var3;
+            }
+        }
+
+        return null;
+    }
+
+    public synchronized void a(int var1, V var2) {
+        int var3 = g(var1);
+        int var4 = a(var3, this.a.length);
+
+        for(IntHashMapEntry var5 = this.a[var4]; var5 != null; var5 = var5.c) {
+            if (var5.a == var1) {
+                var5.b = var2;
+                return;
+            }
+        }
+
+        this.a(var3, var1, var2, var4);
+    }
+
+    private void h(int var1) {
+        IntHashMapEntry[] var2 = this.a;
+        int var3 = var2.length;
+        if (var3 == 1073741824) {
+            this.c = Integer.MAX_VALUE;
+        } else {
+            IntHashMapEntry[] var4 = new IntHashMapEntry[var1];
+            this.a(var4);
+            this.a = var4;
+            this.c = (int)((float)var1 * this.d);
+        }
+    }
+
+    private void a(IntHashMapEntry<V>[] var1) {
+        IntHashMapEntry[] var2 = this.a;
+        int var3 = var1.length;
+
+        for(int var4 = 0; var4 < var2.length; ++var4) {
+            IntHashMapEntry var5 = var2[var4];
+            if (var5 != null) {
+                var2[var4] = null;
+
+                IntHashMapEntry var6;
+                do {
+                    var6 = var5.c;
+                    int var7 = a(var5.d, var3);
+                    var5.c = var1[var7];
+                    var1[var7] = var5;
+                    var5 = var6;
+                } while(var6 != null);
+            }
+        }
+
+    }
+
+    @Nullable
+    public synchronized V d(int var1) {
+        IntHashMapEntry var2 = this.e(var1);
+        return var2 == null ? null : (V) var2.b;
+    }
+
+    @Nullable
+    final IntHashMapEntry<V> e(int var1) {
+        int var2 = g(var1);
+        int var3 = a(var2, this.a.length);
+        IntHashMapEntry var4 = this.a[var3];
+
+        IntHashMapEntry var5;
+        IntHashMapEntry var6;
+        for(var5 = var4; var5 != null; var5 = var6) {
+            var6 = var5.c;
+            if (var5.a == var1) {
+                --this.b;
+                if (var4 == var5) {
+                    this.a[var3] = var6;
+                } else {
+                    var4.c = var6;
+                }
+
+                return var5;
+            }
+
+            var4 = var5;
+        }
+
+        return var5;
+    }
+
+    public synchronized void c() {
+        IntHashMapEntry[] var1 = this.a;
+
+        for(int var2 = 0; var2 < var1.length; ++var2) {
+            var1[var2] = null;
+        }
+
+        this.b = 0;
+    }
+
+    private void a(int var1, int var2, V var3, int var4) {
+        IntHashMapEntry var5 = this.a[var4];
+        this.a[var4] = new IntHashMapEntry(var1, var2, var3, var5);
+        if (this.b++ >= this.c) {
+            this.h(2 * this.a.length);
+        }
+
+    }
+
+    static class IntHashMapEntry<V> {
+        final int a;
+        V b;
+        IntHashMapEntry<V> c;
+        final int d;
+
+        IntHashMapEntry(int var1, int var2, V var3, IntHashMapEntry<V> var4) {
+            this.b = var3;
+            this.c = var4;
+            this.a = var2;
+            this.d = var1;
+        }
+
+        public final synchronized int a() {
+            return this.a;
+        }
+
+        public final synchronized V b() {
+            return this.b;
+        }
+
+        public final synchronized boolean equals(Object var1) {
+            if (!(var1 instanceof IntHashMapEntry)) {
+                return false;
+            } else {
+                IntHashMapEntry var2 = (IntHashMapEntry)var1;
+                if (this.a == var2.a) {
+                    Object var3 = this.b();
+                    Object var4 = var2.b();
+                    if (var3 == var4 || var3 != null && var3.equals(var4)) {
+                        return true;
+                    }
+                }
+
+                return false;
+            }
+        }
+
+        public final synchronized int hashCode() {
+            return IntHashMap.g(this.a);
+        }
+
+        public final synchronized String toString() {
+            return this.a() + "=" + this.b();
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ItemStack.java b/src/main/java/net/minecraft/server/ItemStack.java
index c5f5fa4e7..68c14fefc 100644
--- a/src/main/java/net/minecraft/server/ItemStack.java
+++ b/src/main/java/net/minecraft/server/ItemStack.java
@@ -18,6 +18,7 @@ import org.bukkit.craftbukkit.inventory.CraftItemStack;
 import org.bukkit.craftbukkit.util.CraftMagicNumbers;
 import org.bukkit.entity.Player;
 import org.bukkit.event.world.StructureGrowEvent;
+import org.threadly.concurrent.collections.ConcurrentArrayList;
 // CraftBukkit end
 
 public final class ItemStack {
@@ -187,7 +188,7 @@ public final class ItemStack {
                 }
             }
         }
-        world.captureDrops = new java.util.ArrayList<>(); // Paper - Don't drop items if block place is cancelled
+        world.captureDrops = new ConcurrentArrayList<>();
         EnumInteractionResult enuminteractionresult = this.getItem().a(entityhuman, world, blockposition, enumhand, enumdirection, f, f1, f2);
         int newData = this.getData();
         int newCount = this.getCount();
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 3b982f990..dc103e13f 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -58,7 +58,7 @@ public abstract class MinecraftServer implements ICommandListener, Runnable, IAs
     public Convertable convertable;
     private final MojangStatisticsGenerator m = new MojangStatisticsGenerator("server", this, aw());
     public File universe;
-    private final List<ITickable> o = Lists.newArrayList();
+    private final List<ITickable> o = Lists.newCopyOnWriteArrayList();
     public final ICommandHandler b;
     public final MethodProfiler methodProfiler = new MethodProfiler();
     private ServerConnection p; // Spigot
diff --git a/src/main/java/net/minecraft/server/PaperLightingQueue.java b/src/main/java/net/minecraft/server/PaperLightingQueue.java
index f1c013116..73a715e94 100644
--- a/src/main/java/net/minecraft/server/PaperLightingQueue.java
+++ b/src/main/java/net/minecraft/server/PaperLightingQueue.java
@@ -4,6 +4,7 @@ import co.aikar.timings.Timing;
 import it.unimi.dsi.fastutil.objects.ObjectCollection;
 
 import java.util.ArrayDeque;
+import java.util.concurrent.ConcurrentLinkedDeque;
 
 class PaperLightingQueue {
     private static final long MAX_TIME = (long) (1000000000 / 20 * 1.15);
@@ -31,7 +32,8 @@ class PaperLightingQueue {
         }
     }
 
-    static class LightingQueue extends ArrayDeque<Runnable> {
+    //M2ke4U ArrayDeque->ConcurrentDeque
+    static class LightingQueue extends ConcurrentLinkedDeque<Runnable> {
         final private Chunk chunk;
 
         LightingQueue(Chunk chunk) {
diff --git a/src/main/java/net/minecraft/server/Path.java b/src/main/java/net/minecraft/server/Path.java
new file mode 100644
index 000000000..e71f227bf
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Path.java
@@ -0,0 +1,124 @@
+package net.minecraft.server;
+
+public class Path {
+    private PathPoint[] a = new PathPoint[128];
+    private int b;
+
+    public synchronized PathPoint a(PathPoint pathpoint) {
+        if (pathpoint.d < 0) {
+            if (this.b == this.a.length) {
+                PathPoint[] apathpoint = new PathPoint[this.b << 1];
+
+                System.arraycopy(this.a, 0, apathpoint, 0, this.b);
+                this.a = apathpoint;
+            }
+
+            this.a[this.b] = pathpoint;
+            pathpoint.d = this.b;
+            this.a(this.b++);
+        }
+        return pathpoint;
+    }
+
+    public synchronized void a() {
+        this.b = 0;
+    }
+
+    public synchronized PathPoint c() {
+        PathPoint pathpoint = this.a[0];
+
+        this.a[0] = this.a[--this.b];
+        this.a[this.b] = null;
+        if (this.b > 0) {
+            this.b(0);
+        }
+
+        pathpoint.d = -1;
+        return pathpoint;
+    }
+
+    public synchronized void a(PathPoint pathpoint, float f) {
+        float f1 = pathpoint.g;
+
+        pathpoint.g = f;
+        if (f < f1) {
+            this.a(pathpoint.d);
+        } else {
+            this.b(pathpoint.d);
+        }
+
+    }
+
+    private void a(int i) {
+        PathPoint pathpoint = this.a[i];
+
+        int j;
+
+        for (float f = pathpoint.g; i > 0; i = j) {
+            j = i - 1 >> 1;
+            PathPoint pathpoint1 = this.a[j];
+
+            if (f >= pathpoint1.g) {
+                break;
+            }
+
+            this.a[i] = pathpoint1;
+            pathpoint1.d = i;
+        }
+
+        this.a[i] = pathpoint;
+        pathpoint.d = i;
+    }
+
+    private void b(int i) {
+        PathPoint pathpoint = this.a[i];
+        float f = pathpoint.g;
+
+        while (true) {
+            int j = 1 + (i << 1);
+            int k = j + 1;
+
+            if (j >= this.b) {
+                break;
+            }
+
+            PathPoint pathpoint1 = this.a[j];
+            float f1 = pathpoint1.g;
+            PathPoint pathpoint2;
+            float f2;
+
+            if (k >= this.b) {
+                pathpoint2 = null;
+                f2 = Float.POSITIVE_INFINITY;
+            } else {
+                pathpoint2 = this.a[k];
+                f2 = pathpoint2.g;
+            }
+
+            if (f1 < f2) {
+                if (f1 >= f) {
+                    break;
+                }
+
+                this.a[i] = pathpoint1;
+                pathpoint1.d = i;
+                i = j;
+            } else {
+                if (f2 >= f) {
+                    break;
+                }
+
+                this.a[i] = pathpoint2;
+                pathpoint2.d = i;
+                i = k;
+            }
+        }
+
+        this.a[i] = pathpoint;
+        pathpoint.d = i;
+    }
+
+    public synchronized boolean e() {
+        return this.b == 0;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PathEntity.java b/src/main/java/net/minecraft/server/PathEntity.java
new file mode 100644
index 000000000..9dab0fef7
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PathEntity.java
@@ -0,0 +1,82 @@
+package net.minecraft.server;
+
+import javax.annotation.Nullable;
+
+public class PathEntity {
+    private final PathPoint[] a;
+    private int e;
+    private int f;
+
+    public PathEntity(PathPoint[] var1) {
+        this.a = var1;
+        this.f = var1.length;
+    }
+
+    public void a() {
+        ++this.e;
+    }
+
+    public boolean b() {
+        return this.e >= this.f;
+    }
+
+    @Nullable
+    public PathPoint c() {
+        return this.f > 0 ? this.a[this.f - 1] : null;
+    }
+
+    public PathPoint a(int var1) {
+        return this.a[var1];
+    }
+
+    public void a(int var1, PathPoint var2) {
+        this.a[var1] = var2;
+    }
+
+    public int d() {
+        return this.f;
+    }
+
+    public void b(int var1) {
+        this.f = var1;
+    }
+
+    public int e() {
+        return this.e;
+    }
+
+    public void c(int var1) {
+        this.e = var1;
+    }
+
+    public Vec3D a(Entity var1, int var2) {
+        double var3 = (double)this.a[var2].a + (double)((int)(var1.width + 1.0F)) * 0.5;
+        double var5 = (double)this.a[var2].b;
+        double var7 = (double)this.a[var2].c + (double)((int)(var1.width + 1.0F)) * 0.5;
+        return new Vec3D(var3, var5, var7);
+    }
+
+    public Vec3D a(Entity var1) {
+        return this.a(var1, this.e);
+    }
+
+    public Vec3D f() {
+        PathPoint var1 = this.a[this.e];
+        return new Vec3D((double)var1.a, (double)var1.b, (double)var1.c);
+    }
+
+    public boolean a(PathEntity var1) {
+        if (var1 == null) {
+            return false;
+        } else if (var1.a.length != this.a.length) {
+            return false;
+        } else {
+            for(int var2 = 0; var2 < this.a.length; ++var2) {
+                if (this.a[var2].a != var1.a[var2].a || this.a[var2].b != var1.a[var2].b || this.a[var2].c != var1.a[var2].c) {
+                    return false;
+                }
+            }
+            return true;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Pathfinder.java b/src/main/java/net/minecraft/server/Pathfinder.java
new file mode 100644
index 000000000..86797cae8
--- /dev/null
+++ b/src/main/java/net/minecraft/server/Pathfinder.java
@@ -0,0 +1,120 @@
+//
+// Source code recreated from a .class file by IntelliJ IDEA
+// (powered by FernFlower decompiler)
+//
+
+package net.minecraft.server;
+
+import com.google.common.collect.Sets;
+import java.util.Set;
+import javax.annotation.Nullable;
+
+public class Pathfinder {
+    private final Path a = new Path();
+    private final Set<PathPoint> b = Sets.newConcurrentHashSet();
+    private final PathPoint[] c = new PathPoint[32];
+    private final PathfinderAbstract d;
+
+    public Pathfinder(PathfinderAbstract var1) {
+        this.d = var1;
+    }
+
+    @Nullable
+    public PathEntity a(IBlockAccess var1, EntityInsentient var2, Entity var3, float var4) {
+        return this.a(var1, var2, var3.locX, var3.getBoundingBox().b, var3.locZ, var4);
+    }
+
+    @Nullable
+    public PathEntity a(IBlockAccess var1, EntityInsentient var2, BlockPosition var3, float var4) {
+        return this.a(var1, var2, (double)((float)var3.getX() + 0.5F), (double)((float)var3.getY() + 0.5F), (double)((float)var3.getZ() + 0.5F), var4);
+    }
+
+    @Nullable
+    private PathEntity a(IBlockAccess var1, EntityInsentient var2, double var3, double var5, double var7, float var9) {
+        this.a.a();
+        this.d.a(var1, var2);
+        PathPoint var10 = this.d.b();
+        PathPoint var11 = this.d.a(var3, var5, var7);
+        PathEntity var12 = this.a(var10, var11, var9);
+        this.d.a();
+        return var12;
+    }
+
+    @Nullable
+    private PathEntity a(PathPoint var1, PathPoint var2, float var3) {
+        var1.e = 0.0F;
+        var1.f = var1.c(var2);
+        var1.g = var1.f;
+        this.a.a();
+        this.b.clear();
+        this.a.a(var1);
+        PathPoint var4 = var1;
+        int var5 = 0;
+
+        while(!this.a.e()) {
+            ++var5;
+            if (var5 >= 200) {
+                break;
+            }
+
+            PathPoint var6 = this.a.c();
+            if (var6.equals(var2)) {
+                var4 = var2;
+                break;
+            }
+
+            if (var6.c(var2) < var4.c(var2)) {
+                var4 = var6;
+            }
+
+            var6.i = true;
+            int var7 = this.d.a(this.c, var6, var2, var3);
+
+            for(int var8 = 0; var8 < var7; ++var8) {
+                PathPoint var9 = this.c[var8];
+                float var10 = var6.c(var9);
+                var9.j = var6.j + var10;
+                var9.k = var10 + var9.l;
+                float var11 = var6.e + var9.k;
+                if (var9.j < var3 && (!var9.a() || var11 < var9.e)) {
+                    var9.h = var6;
+                    var9.e = var11;
+                    var9.f = var9.c(var2) + var9.l;
+                    if (var9.a()) {
+                        this.a.a(var9, var9.e + var9.f);
+                    } else {
+                        var9.g = var9.e + var9.f;
+                        this.a.a(var9);
+                    }
+                }
+            }
+        }
+
+        if (var4 == var1) {
+            return null;
+        } else {
+            PathEntity var12 = this.a(var1, var4);
+            return var12;
+        }
+    }
+
+    private PathEntity a(PathPoint var1, PathPoint var2) {
+        int var3 = 1;
+
+        PathPoint var4;
+        for(var4 = var2; var4.h != null; var4 = var4.h) {
+            ++var3;
+        }
+
+        PathPoint[] var5 = new PathPoint[var3];
+        var4 = var2;
+        --var3;
+
+        for(var5[var3] = var2; var4.h != null; var5[var3] = var4) {
+            var4 = var4.h;
+            --var3;
+        }
+
+        return new PathEntity(var5);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PathfinderAbstract.java b/src/main/java/net/minecraft/server/PathfinderAbstract.java
index 7022aabd6..eb99d7128 100644
--- a/src/main/java/net/minecraft/server/PathfinderAbstract.java
+++ b/src/main/java/net/minecraft/server/PathfinderAbstract.java
@@ -2,8 +2,8 @@ package net.minecraft.server;
 
 public abstract class PathfinderAbstract {
 
-    protected IBlockAccess a;
-    protected EntityInsentient b;
+    protected volatile IBlockAccess a;
+    protected volatile EntityInsentient b;
     protected final IntHashMap<PathPoint> c = new IntHashMap();
     protected int d;
     protected int e;
@@ -14,7 +14,7 @@ public abstract class PathfinderAbstract {
 
     public PathfinderAbstract() {}
 
-    public void a(IBlockAccess iblockaccess, EntityInsentient entityinsentient) {
+    public synchronized void a(IBlockAccess iblockaccess, EntityInsentient entityinsentient) {
         this.a = iblockaccess;
         this.b = entityinsentient;
         this.c.c();
@@ -23,7 +23,7 @@ public abstract class PathfinderAbstract {
         this.f = MathHelper.d(entityinsentient.width + 1.0F);
     }
 
-    public void a() {
+    public synchronized void a() {
         this.a = null;
         this.b = null;
     }
diff --git a/src/main/java/net/minecraft/server/PersistentCollection.java b/src/main/java/net/minecraft/server/PersistentCollection.java
index 50056f49a..b2cce1213 100644
--- a/src/main/java/net/minecraft/server/PersistentCollection.java
+++ b/src/main/java/net/minecraft/server/PersistentCollection.java
@@ -3,6 +3,8 @@ package net.minecraft.server;
 import com.destroystokyo.paper.exception.ServerInternalException;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
+import org.threadly.concurrent.collections.ConcurrentArrayList;
+
 import java.io.DataInputStream;
 import java.io.DataOutput;
 import java.io.DataOutputStream;
@@ -19,9 +21,9 @@ import javax.annotation.Nullable;
 public class PersistentCollection {
 
     private final IDataManager b;
-    protected Map<String, PersistentBase> a = Maps.newHashMap();
-    public final List<PersistentBase> c = Lists.newArrayList(); // Spigot
-    private final Map<String, Short> d = Maps.newHashMap();
+    protected Map<String, PersistentBase> a = Maps.newConcurrentMap();
+    public final List<PersistentBase> c = new ConcurrentArrayList<>(); // Spigot
+    private final Map<String, Short> d = Maps.newConcurrentMap();
 
     public PersistentCollection(IDataManager idatamanager) {
         this.b = idatamanager;
diff --git a/src/main/java/net/minecraft/server/PersistentVillage.java b/src/main/java/net/minecraft/server/PersistentVillage.java
index a3aa9f82e..abe00fad9 100644
--- a/src/main/java/net/minecraft/server/PersistentVillage.java
+++ b/src/main/java/net/minecraft/server/PersistentVillage.java
@@ -1,6 +1,6 @@
 package net.minecraft.server;
 
-import com.google.common.collect.Lists;
+import org.threadly.concurrent.collections.ConcurrentArrayList;
 import java.util.Iterator;
 import java.util.List;
 import javax.annotation.Nullable;
@@ -8,9 +8,9 @@ import javax.annotation.Nullable;
 public class PersistentVillage extends PersistentBase {
 
     private World world;
-    private final List<BlockPosition> c = Lists.newArrayList();
-    private final List<VillageDoor> d = Lists.newArrayList();
-    private final List<Village> villages = Lists.newArrayList();
+    private final List<BlockPosition> c = new ConcurrentArrayList<>();
+    private final List<VillageDoor> d = new ConcurrentArrayList<>();
+    private final List<Village> villages = new ConcurrentArrayList<>();
     private int time;
 
     public PersistentVillage(String s) {
diff --git a/src/main/java/net/minecraft/server/PlayerChunk.java b/src/main/java/net/minecraft/server/PlayerChunk.java
index baf72404e..92229b3cf 100644
--- a/src/main/java/net/minecraft/server/PlayerChunk.java
+++ b/src/main/java/net/minecraft/server/PlayerChunk.java
@@ -10,13 +10,14 @@ import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 // CraftBukkit Start
 import org.bukkit.craftbukkit.chunkio.ChunkIOExecutor;
+import org.threadly.concurrent.collections.ConcurrentArrayList;
 // CraftBukkit end
 
 public class PlayerChunk {
 
     private static final Logger a = LogManager.getLogger();
     private final PlayerChunkMap playerChunkMap;
-    public final List<EntityPlayer> c = Lists.newArrayList(); // CraftBukkit - public
+    public final List<EntityPlayer> c = new ConcurrentArrayList<>(); // CraftBukkit - public
     private final ChunkCoordIntPair location;
     private final short[] dirtyBlocks = new short[64];
     @Nullable
diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index 99652ae3e..9fb68e900 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -8,6 +8,9 @@ import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import net.himeki.mcmtfabric.parallelised.fastutil.Long2ObjectOpenConcurrentHashMap;
+import org.threadly.concurrent.collections.ConcurrentArrayList;
+
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
@@ -41,12 +44,12 @@ public class PlayerChunkMap {
         }
     };
     private final WorldServer world;
-    private final List<EntityPlayer> managedPlayers = Lists.newArrayList();
-    private final Long2ObjectMap<PlayerChunk> e = new Long2ObjectOpenHashMap(4096);
-    private final Set<PlayerChunk> f = Sets.newHashSet();
-    private final List<PlayerChunk> g = Lists.newLinkedList();
-    private final List<PlayerChunk> h = Lists.newLinkedList();
-    private final List<PlayerChunk> i = Lists.newArrayList();
+    private final List<EntityPlayer> managedPlayers = new ConcurrentArrayList<>();
+    private final Long2ObjectMap<PlayerChunk> e = new Long2ObjectOpenConcurrentHashMap<>(4096);
+    private final Set<PlayerChunk> f = Sets.newConcurrentHashSet();
+    private final List<PlayerChunk> g = new ConcurrentArrayList<>();
+    private final List<PlayerChunk> h = new ConcurrentArrayList<>();
+    private final List<PlayerChunk> i = new ConcurrentArrayList<>();
     private int j;public int getViewDistance() { return j; } // Paper OBFHELPER
     private long k;
     private boolean l = true;
diff --git a/src/main/java/net/minecraft/server/SpawnerCreature.java b/src/main/java/net/minecraft/server/SpawnerCreature.java
index 5c5bed034..770ad85e0 100644
--- a/src/main/java/net/minecraft/server/SpawnerCreature.java
+++ b/src/main/java/net/minecraft/server/SpawnerCreature.java
@@ -27,7 +27,9 @@ public final class SpawnerCreature {
         if (true) {
             int sum = 0;
             for (Chunk c : server.getChunkProviderServer().chunks.values()) {
-                sum += c.entityCount.get(oClass);
+                synchronized (c){
+                    sum += c.entityCount.get(oClass);
+                }
             }
             return sum;
         }
@@ -41,7 +43,9 @@ public final class SpawnerCreature {
             int z = LongHash.lsw( coord );
             if ( !((ChunkProviderServer)server.chunkProvider).unloadQueue.contains( coord ) && server.isChunkLoaded( x, z, true ) )
             {
-                i += server.getChunkAt( x, z ).entityCount.get( oClass );
+                synchronized (server.getChunkAt( x, z )){
+                    i += server.getChunkAt( x, z ).entityCount.get( oClass );
+                }
             }
         }
         return i;
diff --git a/src/main/java/net/minecraft/server/Village.java b/src/main/java/net/minecraft/server/Village.java
index 6536e5fb8..a220f38a5 100644
--- a/src/main/java/net/minecraft/server/Village.java
+++ b/src/main/java/net/minecraft/server/Village.java
@@ -3,6 +3,7 @@ package net.minecraft.server;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.mojang.authlib.GameProfile;
+import org.threadly.concurrent.collections.ConcurrentArrayList;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
@@ -12,7 +13,7 @@ import javax.annotation.Nullable;
 public class Village {
 
     private World a;
-    private final List<VillageDoor> b = Lists.newArrayList();
+    private final List<VillageDoor> b = new ConcurrentArrayList<>();
     private BlockPosition c;
     private BlockPosition d; private BlockPosition getCenter() { return d; } // Paper - OBFHELPER
     private int e;
@@ -27,15 +28,15 @@ public class Village {
     private Village() { // Paper - Nothing should call this - world needs to be set.
         this.c = BlockPosition.ZERO;
         this.d = BlockPosition.ZERO;
-        this.j = Maps.newHashMap();
-        this.k = Lists.newArrayList();
+        this.j = Maps.newConcurrentMap();
+        this.k = new ConcurrentArrayList<>();
     }
 
     public Village(World world) {
         this.c = BlockPosition.ZERO;
         this.d = BlockPosition.ZERO;
-        this.j = Maps.newHashMap();
-        this.k = Lists.newArrayList();
+        this.j = Maps.newConcurrentMap();
+        this.k = new ConcurrentArrayList<>();
         this.a = world;
     }
 
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index bc231c7f2..e265c5431 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -13,20 +13,22 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Random;
 import java.util.UUID;
-import java.util.function.Supplier;
+import java.util.concurrent.ForkJoinPool;
 import javax.annotation.Nullable;
 
 // CraftBukkit start
 import com.google.common.collect.Maps;
 import java.util.HashMap; // Paper
 import java.util.Map;
+
+import gg.m2ke4u.keyi.AsyncPassedThreadFactory;
+import gg.m2ke4u.keyi.concurrent.ConcurrentTraverse;
 import org.bukkit.Bukkit;
 import org.bukkit.block.BlockState;
 import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.craftbukkit.CraftWorld;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.craftbukkit.util.CraftMagicNumbers;
-import org.bukkit.craftbukkit.util.LongHashSet; // Paper
 import org.bukkit.event.block.BlockCanBuildEvent;
 import org.bukkit.event.block.BlockPhysicsEvent;
 import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
@@ -38,6 +40,7 @@ import java.util.Set;
 import com.destroystokyo.paper.antixray.ChunkPacketBlockController; // Anti-Xray
 import com.destroystokyo.paper.antixray.ChunkPacketBlockControllerAntiXray; // Anti-Xray
 import com.google.common.collect.Sets;
+import org.threadly.concurrent.collections.ConcurrentArrayList;
 // Paper end
 
 public abstract class World implements IBlockAccess {
@@ -46,38 +49,15 @@ public abstract class World implements IBlockAccess {
     protected boolean d;
     // Spigot start - guard entity list from removals
     public static final boolean DEBUG_ENTITIES = Boolean.getBoolean("debug.entities"); // Paper
-    public final List<Entity> entityList = new java.util.ArrayList<Entity>()
-    {
-        @Override
-        public Entity remove(int index)
-        {
-            guard();
-            return super.remove( index );
-        }
-
-        @Override
-        public boolean remove(Object o)
-        {
-            guard();
-            return super.remove( o );
-        }
-
-        private void guard()
-        {
-            if ( guardEntityList )
-            {
-                throw new java.util.ConcurrentModificationException();
-            }
-        }
-    };
+    public final List<Entity> entityList = new ConcurrentArrayList<>();
     // Spigot end
-    protected final Set<Entity> f = Sets.newHashSet(); public Set<Entity> getEntityUnloadQueue() { return f; };// Paper - OBFHELPER
+    protected final Set<Entity> f = Sets.newConcurrentHashSet(); public Set<Entity> getEntityUnloadQueue() { return f; };// Paper - OBFHELPER
     //public final List<TileEntity> tileEntityList = Lists.newArrayList(); // Paper - remove unused list
-    public final List<TileEntity> tileEntityListTick = Lists.newArrayList();
-    private final List<TileEntity> b = Lists.newArrayList();
-    private final Set<TileEntity> tileEntityListUnload = Sets.newHashSet(); // Paper
-    public final List<EntityHuman> players = Lists.newArrayList();
-    public final List<Entity> j = Lists.newArrayList();
+    public final List<TileEntity> tileEntityListTick = new ConcurrentArrayList<>();
+    private final List<TileEntity> b = new ConcurrentArrayList<>();
+    private final Set<TileEntity> tileEntityListUnload = Sets.newConcurrentHashSet(); // Paper
+    public final List<EntityHuman> players = new ConcurrentArrayList<>();
+    public final List<Entity> j = new ConcurrentArrayList<>();
     protected final IntHashMap<Entity> entitiesById = new IntHashMap();
     private final long K = 16777215L;
     private int L; private int getSkylightSubtracted() { return this.L; } // Paper - OBFHELPER
@@ -119,17 +99,14 @@ public abstract class World implements IBlockAccess {
 
     public boolean captureBlockStates = false;
     public boolean captureTreeGeneration = false;
-    public ArrayList<BlockState> capturedBlockStates= new ArrayList<BlockState>(){
+    public ArrayList<BlockState> capturedBlockStates= new ConcurrentArrayList<BlockState>(){
         @Override
         public boolean add( BlockState blockState ) {
-            Iterator<BlockState> blockStateIterator = this.iterator();
-            while( blockStateIterator.hasNext() ) {
-                BlockState blockState1 = blockStateIterator.next();
-                if ( blockState1.getLocation().equals( blockState.getLocation() ) ) {
+            for (BlockState blockState1 : this) {
+                if (blockState1.getLocation().equals(blockState.getLocation())) {
                     return false;
                 }
             }
-
             return super.add( blockState );
         }
     };
@@ -137,7 +114,6 @@ public abstract class World implements IBlockAccess {
     public long ticksPerAnimalSpawns;
     public long ticksPerMonsterSpawns;
     public boolean populating;
-    private int tickPosition;
     public final org.spigotmc.SpigotWorldConfig spigotConfig; // Spigot
 
     public final com.destroystokyo.paper.PaperWorldConfig paperConfig; // Paper
@@ -1288,17 +1264,10 @@ public abstract class World implements IBlockAccess {
         }
         entity.shouldBeRemoved = true; // Paper
 
-        if (!guardEntityList) { // Spigot - It will get removed after the tick if we are ticking // Paper - always remove from current chunk above
-        // CraftBukkit start - Decrement loop variable field if we've already ticked this entity
         int index = this.entityList.indexOf(entity);
         if (index != -1) {
-            if (index <= this.tickPosition) {
-                this.tickPosition--;
-            }
             this.entityList.remove(index);
         }
-        // CraftBukkit end
-        } // Spigot
         this.c(entity);
     }
 
@@ -1477,35 +1446,22 @@ public abstract class World implements IBlockAccess {
 
     public void b(BlockPosition blockposition, Block block, int i, int j) {}
 
+    private static final ForkJoinPool entitiesExecutor = AsyncPassedThreadFactory.getNewPool();
+
     public void tickEntities() {
         this.methodProfiler.a("entities");
         this.methodProfiler.a("global");
 
-        int i;
-        Entity entity;
-
-        for (i = 0; i < this.j.size(); ++i) {
-            entity = (Entity) this.j.get(i);
-            // CraftBukkit start - Fixed an NPE
+        for (int i = 0; i < this.j.size(); ++i) {
+            Entity entity = (Entity) this.j.get(i);
             if (entity == null) {
                 continue;
             }
-            // CraftBukkit end
-
             try {
                 ++entity.ticksLived;
                 entity.B_();
             } catch (Throwable throwable) {
-                CrashReport crashreport = CrashReport.a(throwable, "Ticking entity");
-                CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Entity being ticked");
-
-                if (entity == null) {
-                    crashreportsystemdetails.a("Entity", (Object) "~~NULL~~");
-                } else {
-                    entity.appendEntityCrashDetails(crashreportsystemdetails);
-                }
-
-                throw new ReportedException(crashreport);
+                throwable.printStackTrace();
             }
 
             if (entity.dead) {
@@ -1517,16 +1473,8 @@ public abstract class World implements IBlockAccess {
         timings.entityRemoval.startTiming(); // Paper
         this.entityList.removeAll(this.f);
 
-        int j;
         // Paper start - Set based removal lists
         for (Entity e : this.f) {
-            /*
-            j = e.getChunkZ();
-            int k = e.getChunkX();
-
-            if (e.isAddedToChunk() && this.isChunkLoaded(k, j, true)) {
-                this.getChunkAt(k, j).b(e);
-            }*/
             Chunk chunk = e.isAddedToChunk() ? e.getCurrentChunk() : null;
             if (chunk != null) chunk.removeEntity(e);
         }
@@ -1546,27 +1494,15 @@ public abstract class World implements IBlockAccess {
 
         org.spigotmc.ActivationRange.activateEntities(this); // Spigot
         timings.entityTick.startTiming(); // Spigot
-        guardEntityList = true; // Spigot
-        // CraftBukkit start - Use field for loop variable
         co.aikar.timings.TimingHistory.entityTicks += this.entityList.size(); // Paper
-        int entitiesThisCycle = 0;
-        // Paper start - Disable tick limiters
-        //if (tickPosition < 0) tickPosition = 0;
-        for (tickPosition = 0; tickPosition < entityList.size(); tickPosition++) {
-            // Paper end
-            tickPosition = (tickPosition < entityList.size()) ? tickPosition : 0;
-            entity = (Entity) this.entityList.get(this.tickPosition);
-            // CraftBukkit end
+        ConcurrentTraverse.traverseSync(this.entityList,entity->{
             Entity entity1 = entity.bJ();
-
             if (entity1 != null) {
                 if (!entity1.dead && entity1.w(entity)) {
-                    continue;
+                    return;
                 }
-
                 entity.stopRiding();
             }
-
             this.methodProfiler.a("tick");
             if (!entity.dead && !(entity instanceof EntityPlayer)) {
                 try {
@@ -1575,41 +1511,23 @@ public abstract class World implements IBlockAccess {
                     entity.tickTimer.stopTiming(); // Paper
                 } catch (Throwable throwable1) {
                     entity.tickTimer.stopTiming();
-                    // Paper start - Prevent tile entity and entity crashes
                     String msg = "Entity threw exception at " + entity.world.getWorld().getName() + ":" + entity.locX + "," + entity.locY + "," + entity.locZ;
-                    System.err.println(msg);
                     throwable1.printStackTrace();
                     getServer().getPluginManager().callEvent(new ServerExceptionEvent(new ServerInternalException(msg, throwable1)));
-                    entity.dead = true;
-                    continue;
-                    // Paper end
                 }
             }
 
             this.methodProfiler.b();
             this.methodProfiler.a("remove");
             if (entity.dead) {
-                // Paper start
-                /*
-                j = entity.ab;
-                int l = entity.ad;
-
-                /*if (entity.aa && this.isChunkLoaded(j, l, true)) {
-                    this.getChunkAt(j, l).b(entity);
-                }*/
                 Chunk chunk = entity.isAddedToChunk() ? entity.getCurrentChunk() : null;
                 if (chunk != null) chunk.removeEntity(entity);
-                // Paper end
-
-                guardEntityList = false; // Spigot
-                this.entityList.remove(this.tickPosition--); // CraftBukkit - Use field for loop variable
-                guardEntityList = true; // Spigot
+                this.entityList.remove(entity); // CraftBukkit - Use field for loop variable
                 this.c(entity);
             }
 
             this.methodProfiler.b();
-        }
-        guardEntityList = false; // Spigot
+        },entitiesExecutor);
 
         timings.entityTick.stopTiming(); // Spigot
         this.methodProfiler.c("blockEntities");
@@ -1625,18 +1543,12 @@ public abstract class World implements IBlockAccess {
         }
 
         this.O = true;
-        // Spigot start
-        // Iterator iterator = this.tileEntityListTick.iterator();
-        int tilesThisCycle = 0;
-        for (tileTickPosition = 0; tileTickPosition < tileEntityListTick.size(); tileTickPosition++) { // Paper - Disable tick limiters
-            tileTickPosition = (tileTickPosition < tileEntityListTick.size()) ? tileTickPosition : 0;
-            TileEntity tileentity = (TileEntity) this.tileEntityListTick.get(tileTickPosition);
+        ConcurrentTraverse.traverseSync(this.tileEntityListTick,tileentity->{
             // Spigot start
             if (tileentity == null) {
                 getServer().getLogger().severe("Spigot has detected a null entity and has removed it, preventing a crash");
-                tilesThisCycle--;
                 this.tileEntityListTick.remove(tileTickPosition--);
-                continue;
+                return;
             }
             // Spigot end
 
@@ -1660,12 +1572,9 @@ public abstract class World implements IBlockAccess {
                     } catch (Throwable throwable2) {
                         // Paper start - Prevent tile entity and entity crashes
                         String msg = "TileEntity threw exception at " + tileentity.world.getWorld().getName() + ":" + tileentity.position.getX() + "," + tileentity.position.getY() + "," + tileentity.position.getZ();
-                        System.err.println(msg);
                         throwable2.printStackTrace();
                         getServer().getPluginManager().callEvent(new ServerExceptionEvent(new ServerInternalException(msg, throwable2)));
-                        tilesThisCycle--;
-                        this.tileEntityListTick.remove(tileTickPosition--);
-                        continue;
+                        return;
                         // Paper end
                     }
                     // Spigot start
@@ -1677,8 +1586,7 @@ public abstract class World implements IBlockAccess {
             }
 
             if (tileentity.y()) {
-                tilesThisCycle--;
-                this.tileEntityListTick.remove(tileTickPosition--);
+                this.tileEntityListTick.remove(tileentity);
                 //this.tileEntityList.remove(tileentity); // Paper - remove unused list
                 // Paper start
                 net.minecraft.server.Chunk chunk = tileentity.getCurrentChunk();
@@ -1687,38 +1595,26 @@ public abstract class World implements IBlockAccess {
                     // Paper end
                 }
             }
-        }
+        },entitiesExecutor);
 
         timings.tileEntityTick.stopTiming(); // Spigot
         timings.tileEntityPending.startTiming(); // Spigot
         this.O = false;
         this.methodProfiler.c("pendingBlockEntities");
         if (!this.b.isEmpty()) {
-            for (int i1 = 0; i1 < this.b.size(); ++i1) {
-                TileEntity tileentity1 = (TileEntity) this.b.get(i1);
-
+            ConcurrentTraverse.traverseSync(this.b,tileentity1->{
                 if (!tileentity1.y()) {
-                    /* CraftBukkit start - Order matters, moved down
-                    if (!this.tileEntityList.contains(tileentity1)) {
-                        this.a(tileentity1);
-                    }
-                    // CraftBukkit end */
-
                     if (this.isLoaded(tileentity1.getPosition())) {
                         Chunk chunk = this.getChunkAtWorldCoords(tileentity1.getPosition());
                         IBlockData iblockdata = chunk.getBlockData(tileentity1.getPosition());
 
                         chunk.a(tileentity1.getPosition(), tileentity1);
                         this.notify(tileentity1.getPosition(), iblockdata, iblockdata, 3);
-                        // CraftBukkit start
-                        // From above, don't screw this up - SPIGOT-1746
-                        if (true) { // Paper - remove unused list
-                            this.a(tileentity1);
-                        }
+                        this.a(tileentity1);
                         // CraftBukkit end
                     }
                 }
-            }
+            },entitiesExecutor);
 
             this.b.clear();
         }
diff --git a/src/main/java/org/bukkit/craftbukkit/util/UnsafeList.java b/src/main/java/org/bukkit/craftbukkit/util/UnsafeList.java
index 08d105603..7fd03a9bb 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/UnsafeList.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/UnsafeList.java
@@ -12,6 +12,7 @@ import java.util.List;
 import java.util.NoSuchElementException;
 import java.util.RandomAccess;
 
+//M2ke4U -- Thread safe fix
 // implementation of an ArrayList that offers a getter without range checks
 @SuppressWarnings("unchecked")
 public class UnsafeList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, Serializable {
@@ -43,17 +44,17 @@ public class UnsafeList<E> extends AbstractList<E> implements List<E>, RandomAcc
         this(32);
     }
 
-    public E get(int index) {
+    public synchronized E get(int index) {
         rangeCheck(index);
 
         return (E) data[index];
     }
 
-    public E unsafeGet(int index) {
+    public synchronized E unsafeGet(int index) {
         return (E) data[index];
     }
 
-    public E set(int index, E element) {
+    public synchronized E set(int index, E element) {
         rangeCheck(index);
 
         E old = (E) data[index];
@@ -61,20 +62,20 @@ public class UnsafeList<E> extends AbstractList<E> implements List<E>, RandomAcc
         return old;
     }
 
-    public boolean add(E element) {
+    public synchronized boolean add(E element) {
         growIfNeeded();
         data[size++] = element;
         return true;
     }
 
-    public void add(int index, E element) {
+    public synchronized void add(int index, E element) {
         growIfNeeded();
         System.arraycopy(data, index, data, index + 1, size - index);
         data[index] = element;
         size++;
     }
 
-    public E remove(int index) {
+    public synchronized E remove(int index) {
         rangeCheck(index);
 
         E old = (E) data[index];
@@ -87,7 +88,7 @@ public class UnsafeList<E> extends AbstractList<E> implements List<E>, RandomAcc
         return old;
     }
 
-    public boolean remove(Object o) {
+    public synchronized boolean remove(Object o) {
         int index = indexOf(o);
         if (index >= 0) {
             remove(index);
@@ -97,7 +98,7 @@ public class UnsafeList<E> extends AbstractList<E> implements List<E>, RandomAcc
         return false;
     }
 
-    public int indexOf(Object o) {
+    public synchronized int indexOf(Object o) {
         for (int i = 0; i < size; i++) {
             if (o == data[i] || o.equals(data[i])) {
                 return i;
@@ -107,11 +108,11 @@ public class UnsafeList<E> extends AbstractList<E> implements List<E>, RandomAcc
         return -1;
     }
 
-    public boolean contains(Object o) {
+    public synchronized boolean contains(Object o) {
         return indexOf(o) >= 0;
     }
 
-    public void clear() {
+    public synchronized void clear() {
         // Create new array to reset memory usage to initial capacity
         size = 0;
 
@@ -126,7 +127,7 @@ public class UnsafeList<E> extends AbstractList<E> implements List<E>, RandomAcc
     }
 
     // actually rounds up to nearest power of two
-    public void trimToSize() {
+    public synchronized void trimToSize() {
         int old = data.length;
         int rounded = Integer.highestOneBit(size - 1) << 1;
         if (rounded < old) {
@@ -134,15 +135,15 @@ public class UnsafeList<E> extends AbstractList<E> implements List<E>, RandomAcc
         }
     }
 
-    public int size() {
+    public synchronized int size() {
         return size;
     }
 
-    public boolean isEmpty() {
+    public synchronized boolean isEmpty() {
         return size == 0;
     }
 
-    public Object clone() throws CloneNotSupportedException {
+    public synchronized Object clone() throws CloneNotSupportedException {
         UnsafeList<E> copy = (UnsafeList<E>) super.clone();
         copy.data = Arrays.copyOf(data, size);
         copy.size = size;
@@ -154,7 +155,7 @@ public class UnsafeList<E> extends AbstractList<E> implements List<E>, RandomAcc
         return copy;
     }
 
-    public Iterator<E> iterator() {
+    public synchronized Iterator<E> iterator() {
         // Try to find an iterator that isn't in use
         for (Iterator iter : iterPool) {
             if (!((Itr) iter).valid) {
@@ -226,19 +227,19 @@ public class UnsafeList<E> extends AbstractList<E> implements List<E>, RandomAcc
         int expectedModCount = modCount;
         public boolean valid = true;
 
-        public void reset() {
+        public synchronized void reset() {
             index = 0;
             lastRet = -1;
             expectedModCount = modCount;
             valid = true;
         }
 
-        public boolean hasNext() {
+        public synchronized boolean hasNext() {
             valid = index != size;
             return valid;
         }
 
-        public E next() {
+        public synchronized E next() {
             if (modCount != expectedModCount) {
                 throw new ConcurrentModificationException();
             }
@@ -256,7 +257,7 @@ public class UnsafeList<E> extends AbstractList<E> implements List<E>, RandomAcc
             return (E) data[lastRet = i];
         }
 
-        public void remove() {
+        public synchronized void remove() {
             if (lastRet < 0) {
                 throw new IllegalStateException();
             }
diff --git a/src/main/java/org/spigotmc/AsyncCatcher.java b/src/main/java/org/spigotmc/AsyncCatcher.java
index e44c23016..adc6f1b3c 100644
--- a/src/main/java/org/spigotmc/AsyncCatcher.java
+++ b/src/main/java/org/spigotmc/AsyncCatcher.java
@@ -1,5 +1,6 @@
 package org.spigotmc;
 
+import gg.m2ke4u.keyi.AsyncPassedThreadFactory;
 import net.minecraft.server.MinecraftServer;
 
 public class AsyncCatcher
@@ -10,7 +11,7 @@ public class AsyncCatcher
 
     public static void catchOp(String reason)
     {
-        if ( enabled && Thread.currentThread() != MinecraftServer.getServer().primaryThread )
+        if ( enabled && Thread.currentThread() != MinecraftServer.getServer().primaryThread && !AsyncPassedThreadFactory.currentThreadContains())
         {
             throw new IllegalStateException( "Asynchronous " + reason + "!" );
         }
diff --git a/src/main/java/org/threadly/concurrent/collections/ConcurrentArrayList.java b/src/main/java/org/threadly/concurrent/collections/ConcurrentArrayList.java
new file mode 100644
index 000000000..394941c8b
--- /dev/null
+++ b/src/main/java/org/threadly/concurrent/collections/ConcurrentArrayList.java
@@ -0,0 +1,1487 @@
+package org.threadly.concurrent.collections;
+
+import java.util.*;
+
+import org.threadly.util.ArgumentVerifier;
+
+/**
+ * A thread safe list implementation with an array back end.  Make sure to read the javadocs 
+ * carefully, as several functions behave subtly different from the java.util.List definition.
+ * <p>
+ * The design of this implementation is NOT to completely avoid synchronization.  We have a hybrid 
+ * implementation of volatile and synchronized to allow for cheaper reading, but keeping high 
+ * consistency.  It works with the idea that the internal data is immutable.  Each read has an 
+ * immutable version of the data.  Thus making writes more expensive (almost like a 
+ * {@link java.util.concurrent.CopyOnWriteArrayList}).
+ * <p>
+ * There are several differences between this and a CopyOnWriteArrayList.  The first being that we 
+ * don't have to copy the structure on every write operation.  By setting the front and/or rear 
+ * padding, we can add items to the front or end of the list while avoiding a copy operation.  In 
+ * addition removals also do not require a copy operation.  Furthermore, this implementation 
+ * differs from  a CopyOnWriteArrayList is that it does allow some synchronization.  Which can 
+ * give higher consistency guarantees for some operations by allowing you to synchronize on the 
+ * modification lock to perform multiple atomic operations.
+ * <p>
+ * The main motivation in implementing this was to avoid array copies as much as possible (which 
+ * for large lists can be costly).  But also the implementation to cheaply reposition an item in 
+ * the list was necessary for other performance benefits.
+ * <p>
+ * A couple notable points is that subList calls are very cheap, but modifications to sublist are 
+ * completely independent from their source list.
+ * <p>
+ * Unlike CopyOnWriteArrayList, Iterators can attempt to modify the state of the backing structure 
+ * (assuming it still makes sense to do so).  Although unlike CopyOnWriteArrayList iterators, once 
+ * an Iterator is created it will never see updates to the structure.  For that reason it is 
+ * impossible to have a {@code ConcurrentModificationExcception}.
+ * 
+ * @since 1.0.0
+ * @param <T> type of object to retain
+ */
+public class ConcurrentArrayList<T> extends ArrayList<T> implements Deque<T>, RandomAccess {
+  private static final short HASH_CODE_PRIME_NUMBER = 31;
+  private static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];
+  
+  protected static <E> DataSet<E> makeEmptyDataSet(int frontPadding, int rearPadding) {
+    ArgumentVerifier.assertNotNegative(frontPadding, "frontPadding");
+    ArgumentVerifier.assertNotNegative(rearPadding, "rearPadding");
+    
+    return new DataSet<>(EMPTY_OBJECT_ARRAY, 0, 0, frontPadding, rearPadding);
+  }
+  
+  protected final Object modificationLock;
+  protected volatile DataSet<T> currentData;
+  
+  /**
+   * Constructs a new {@link ConcurrentArrayList} with a new internal NativeLock implementation.
+   */
+  public ConcurrentArrayList() {
+    this(0, 0);
+  }
+  
+  /**
+   * Constructs a new {@link ConcurrentArrayList} with specific padding.  Specifying the padding 
+   * amounts can optimize this implementation more for the specific use case.  If there is space 
+   * in the array for adds to the front or end, then we are able to avoid an array copy.
+   * 
+   * @param frontPadding padding to add to front of array to possible avoid array copies
+   * @param rearPadding padding to add to end of array to possible avoid array copies
+   */
+  public ConcurrentArrayList(int frontPadding, int rearPadding) {
+    this(null, frontPadding, rearPadding);
+  }
+
+  /**
+   * Constructs a new {@link ConcurrentArrayList} with a provided lock object.  This is the lock 
+   * used to guard modifications, and is returned from {@link #getModificationLock()}.
+   * 
+   * @param modificationLock lock to synchronize on internally
+   */
+  protected ConcurrentArrayList(Object modificationLock) {
+    this(modificationLock, 0, 0);
+  }
+
+  public ConcurrentArrayList(Collection<? extends T> collection){
+    this();
+    this.addAll(collection);
+  }
+
+  /**
+   * Constructs a new {@link ConcurrentArrayList} with a provided lock object.  This is the lock 
+   * used to guard modifications, and is returned from {@link #getModificationLock()}.  Specifying 
+   * the padding amounts can optimize this implementation more for the specific use case.  If 
+   * there is space in the array for adds to the front or end, then we are able to avoid an array 
+   * copy.
+   * 
+   * @param modificationLock lock to synchronize on internally
+   * @param frontPadding padding to add to front of array to possible avoid array copies
+   * @param rearPadding padding to add to end of array to possible avoid array copies
+   */
+  protected ConcurrentArrayList(Object modificationLock, int frontPadding, int rearPadding) {
+    this(ConcurrentArrayList.<T>makeEmptyDataSet(frontPadding, rearPadding), modificationLock);
+  }
+  
+  /**
+   * Internal constructor which provides the modification lock and the initial {@link DataSet}.  
+   * This is used for constructing sub-lists, but may also be useful to extending classes.
+   * 
+   * @param startSet {@link DataSet} to use internally
+   * @param modificationLock lock to synchronize on internally
+   */
+  protected ConcurrentArrayList(DataSet<T> startSet, Object modificationLock) {
+    ArgumentVerifier.assertNotNull(startSet, "startSet");
+    if (modificationLock == null) {
+      modificationLock = new Object();
+    }
+    
+    this.modificationLock = modificationLock;
+    currentData = startSet;
+  }
+  
+  /**
+   * If you want to chain multiple calls together and ensure that no threads modify the structure 
+   * during that time you can get the lock to prevent additional modifications.  
+   * <p>
+   * This lock should be synchronized on to prevent modifications.
+   * 
+   * @return lock used internally
+   */
+  public Object getModificationLock() {
+    return modificationLock;
+  }
+  
+  /**
+   * This changes the configuration for the front padding amount for future modification 
+   * operations.
+   * 
+   * @param frontPadding New value to over allocate the front of new buffers
+   */
+  public void setFrontPadding(int frontPadding) {
+    ArgumentVerifier.assertNotNegative(frontPadding, "frontPadding");
+    
+    synchronized (modificationLock) {
+      currentData.frontPadding = frontPadding;
+    }
+  }
+
+  /**
+   * This changes the configuration for the rear padding amount for future modification operations.
+   * 
+   * @param rearPadding New value to over allocate the rear of new buffers
+   */
+  public void setRearPadding(int rearPadding) {
+    ArgumentVerifier.assertNotNegative(rearPadding, "rearPadding");
+
+    synchronized (modificationLock) {
+      currentData.rearPadding = rearPadding;
+    }
+  }
+  
+  /**
+   * Getter for current amount to added padding to the front of new buffers.
+   * 
+   * @return current amount to added padding to the front of new buffers
+   */
+  public int getFrontPadding() {
+    return currentData.frontPadding;
+  }
+
+  /**
+   * Getter for current amount to added padding to the rear of new buffers.
+   * 
+   * @return current amount to added padding to the rear of new buffers
+   */
+  public int getRearPadding() {
+    return currentData.rearPadding;
+  }
+
+  /**
+   * Trims the internally array to discard any unused storage.  It is good to invoke this if 
+   * future adds are unlikely, and it is desired to keep memory usage minimal.  This does not 
+   * adjust the set front or rear padding, so additional modifications will expand the array based 
+   * off those set values.  To make sure additional modifications do not expand the array any more 
+   * than necessary invoke {@link #setFrontPadding(int)} and {@link #setRearPadding(int)} with 
+   * {@code 0}.
+   */
+  public void trimToSize() {
+    synchronized (modificationLock) {
+      currentData = currentData.trimToSize();
+    }
+  }
+
+  @Override
+  public int size() {
+    return currentData.size;
+  }
+
+  @Override
+  public boolean isEmpty() {
+    return currentData.size == 0;
+  }
+  
+  @Override
+  public T get(int index) {
+    try {
+      return currentData.get(index);
+    } catch (ArrayIndexOutOfBoundsException e) {
+      // translate to the expected exception type
+      throw new IndexOutOfBoundsException();
+    }
+  }
+
+  @Override
+  public int indexOf(Object o) {
+    return currentData.indexOf(o);
+  }
+
+  @Override
+  public int lastIndexOf(Object o) {
+    return currentData.lastIndexOf(o);
+  }
+
+  @Override
+  public boolean contains(Object o) {
+    return currentData.indexOf(o) >= 0;
+  }
+
+  @Override
+  public boolean containsAll(Collection<?> c) {
+    if (c == null || c.isEmpty()) {
+      return true;
+    }
+    
+    DataSet<T> workingSet = currentData;
+    Iterator<?> it = c.iterator();
+    while (it.hasNext()) {
+      if (workingSet.indexOf(it.next()) < 0) {
+        return false;
+      }
+    }
+    
+    return true;
+  }
+
+  @Override
+  public Object[] toArray() {
+    DataSet<T> workingSet = currentData;
+
+    return Arrays.copyOfRange(workingSet.dataArray, 
+                              workingSet.dataStartIndex, workingSet.dataEndIndex);
+  }
+
+  @SuppressWarnings("unchecked")
+  @Override
+  public <E> E[] toArray(E[] a) {
+    DataSet<T> workingSet = currentData;
+    
+    if (a.length < workingSet.size) {
+      return (E[])Arrays.copyOfRange(workingSet.dataArray, 
+                                     workingSet.dataStartIndex, 
+                                     workingSet.dataEndIndex, 
+                                     a.getClass());
+    } else {
+      System.arraycopy(workingSet.dataArray, workingSet.dataStartIndex, a, 0, workingSet.size);
+      
+      return a;
+    }
+  }
+
+  @Override
+  public boolean add(T e) {
+    if (e == null) {
+      return false;
+    }
+    
+    synchronized (modificationLock) {
+      currentData = currentData.addToEnd(e);
+    }
+    
+    return true;
+  }
+
+  @Override
+  public boolean addAll(Collection<? extends T> c) {
+    if (c == null || c.isEmpty()) {
+      return false;
+    }
+    
+    Iterator<? extends T> it = c.iterator();
+    while (it.hasNext()) {
+      if (it.next() == null) {
+        throw new IllegalArgumentException("Can not store null values");
+      }
+    }
+
+    synchronized (modificationLock) {
+      currentData = currentData.addAll(c);
+    }
+    
+    return true;
+  }
+
+  @Override
+  public boolean addAll(int index, Collection<? extends T> c) {
+    if (index < 0) {
+      throw new IndexOutOfBoundsException("Index can not be negative");
+    } else if (c == null) {
+      return false;
+    }
+    
+    Iterator<? extends T> it = c.iterator();
+    while (it.hasNext()) {
+      if (it.next() == null) {
+        it.remove();
+      }
+    }
+    if (c.isEmpty()) {
+      return false;
+    }
+
+    synchronized (modificationLock) {
+      if (index > currentData.size) {
+        throw new IndexOutOfBoundsException("Index is beyond the array size: " + index);
+      }
+      
+      currentData = currentData.addAll(index, c);
+    }
+    
+    return true;
+  }
+
+  @Override
+  public boolean retainAll(Collection<?> c) {
+    if (c == this) {
+      return false;
+    } else if (c == null || c.isEmpty()) {
+      if (isEmpty()) {
+        return false;
+      } else {
+        clear();
+        
+        return true;
+      }
+    }
+    
+    DataSet<T> originalSet;
+    DataSet<T> resultSet;
+    synchronized (modificationLock) {
+      originalSet = currentData;
+      currentData = resultSet = currentData.retainAll(c);
+    }
+    
+    return ! resultSet.equalsExactly(originalSet);
+  }
+
+  @Override
+  public void clear() {
+    synchronized (modificationLock) {
+      currentData = makeEmptyDataSet(currentData.frontPadding, currentData.rearPadding);
+    }
+  }
+  
+  @Override
+  public void addFirst(T e) {
+    // nulls can't be accepted because of how we attempt to prevent array copies
+    if (e == null) {
+      throw new UnsupportedOperationException("This structure can not accept nulls");
+    }
+    
+    synchronized (modificationLock) {
+      currentData = currentData.addToFront(e);
+    }
+  }
+
+  @Override
+  public void addLast(T e) {
+    // nulls can't be accepted because of how we attempt to prevent array copies
+    if (e == null) {
+      throw new UnsupportedOperationException("This structure can not accept nulls");
+    }
+    
+    synchronized (modificationLock) {
+      currentData = currentData.addToEnd(e);
+    }
+  }
+
+  @Override
+  public boolean offerFirst(T e) {
+    addFirst(e);
+      
+    // this implementation has no capacity limit
+    return true;
+  }
+
+  @Override
+  public boolean offerLast(T e) {
+    addLast(e);
+      
+    // this implementation has no capacity limit
+    return true;
+  }
+
+  @Override
+  public T removeFirst() {
+    T result = pollFirst();
+    if (result == null) {
+      throw new NoSuchElementException();
+    }
+    
+    return result;
+  }
+
+  @Override
+  public T removeLast() {
+    T result = pollLast();
+    if (result == null) {
+      throw new NoSuchElementException();
+    }
+    
+    return result;
+  }
+
+  @Override
+  public T pollFirst() {
+    synchronized (modificationLock) {
+      T result = peekFirst();
+      if (result != null) {
+        currentData = currentData.remove(0);
+      }
+      
+      return result;
+    }
+  }
+
+  @Override
+  public T pollLast() {
+    synchronized (modificationLock) {
+      T result = peekLast();
+      if (result != null) {
+        currentData = currentData.remove(currentData.size - 1);
+      }
+      
+      return result;
+    }
+  }
+
+  @Override
+  public T getFirst() {
+    T result = peekFirst();
+    if (result == null) {
+      throw new NoSuchElementException();
+    }
+    
+    return result;
+  }
+
+  @Override
+  public T getLast() {
+    T result = peekLast();
+    if (result == null) {
+      throw new NoSuchElementException();
+    }
+    
+    return result;
+  }
+
+  @Override
+  public T peek() {
+    return peekFirst();
+  }
+
+  @Override
+  public T peekFirst() {
+    DataSet<T> set = currentData;
+    if (set.size > 0) {
+      return set.get(0);
+    } else {
+      return null;
+    }
+  }
+
+  @Override
+  public T peekLast() {
+    DataSet<T> set = currentData;
+    if (set.size > 0) {
+      return set.get(set.size - 1);
+    } else {
+      return null;
+    }
+  }
+
+  @Override
+  public boolean removeAll(Collection<?> c) {
+    if (c == null || c.isEmpty()) {
+      return false;
+    }
+
+    DataSet<T> originalSet;
+    DataSet<T> resultSet;
+    synchronized (modificationLock) {
+      originalSet = currentData;
+      currentData = resultSet = currentData.removeAll(c);
+    }
+    
+    return ! resultSet.equalsExactly(originalSet);
+  }
+
+  protected boolean remove(Object o, boolean searchBackwards) {
+    if (o == null) {
+      return false;
+    }
+    
+    synchronized (modificationLock) {
+      int index;
+      if (searchBackwards) {
+        index = currentData.lastIndexOf(o);
+      } else {
+        index = currentData.indexOf(o);
+      }
+      if (index < 0) {
+        return false;
+      } else {
+        currentData = currentData.remove(index);
+        return true;
+      }
+    }
+  }
+
+  @Override
+  public boolean removeFirstOccurrence(Object o) {
+    return remove(o, false);
+  }
+
+  @Override
+  public boolean removeLastOccurrence(Object o) {
+    return remove(o, true);
+  }
+
+  @Override
+  public boolean remove(Object o) {
+    return removeFirstOccurrence(o);
+  }
+
+  @Override
+  public T remove(int index) {
+    if (index < 0) {
+      throw new IndexOutOfBoundsException("Index can not be negative");
+    }
+    
+    DataSet<T> originalSet;
+    synchronized (modificationLock) {
+      if (index > currentData.size - 1) {
+        throw new IndexOutOfBoundsException("Index is beyond the array max index: " + index);
+      }
+      
+      originalSet = currentData;
+      currentData = currentData.remove(index);
+    }
+    
+    return originalSet.get(index);
+  }
+
+  @Override
+  public boolean offer(T e) {
+    return offerLast(e);
+  }
+
+  @Override
+  public T remove() {
+    return removeFirst();
+  }
+
+  @Override
+  public T poll() {
+    return pollFirst();
+  }
+
+  @Override
+  public T element() {
+    return getFirst();
+  }
+
+  @Override
+  public void push(T e) {
+    addFirst(e);
+  }
+
+  @Override
+  public T pop() {
+    return removeFirst();
+  }
+
+  @Override
+  public T set(int index, T element) {
+    if (index < 0) {
+      throw new IndexOutOfBoundsException("Index can not be negative");
+    }
+    
+    DataSet<T> originalSet;
+    synchronized (modificationLock) {
+      if (index > currentData.size - 1) {
+        throw new IndexOutOfBoundsException("Index is beyond the array max index: " + index);
+      }
+      
+      originalSet = currentData;
+      currentData = currentData.set(index, element);
+    }
+    
+    return originalSet.get(index);
+  }
+
+  @Override
+  public void add(int index, T element) {
+    if (index < 0) {
+      throw new IndexOutOfBoundsException("Index can not be negative");
+    }
+    
+    synchronized (modificationLock) {
+      if (index > currentData.size) {
+        throw new IndexOutOfBoundsException("Index is beyond the array size: " + index);
+      }
+      
+      currentData = currentData.add(index, element);
+    }
+  }
+  
+  /**
+   * Move a stored item to a new index.  By default a forward search will happen to find the item.
+   * 
+   * @param item item to be moved
+   * @param newIndex new index for placement
+   */
+  public void reposition(T item, int newIndex) {
+    reposition(item, newIndex, false);
+  }
+  
+  /**
+   * Move a stored item to a new index.  If you have an idea if it is closer to the start or end of 
+   * the list you can specify which end to start the search on.
+   * 
+   * @param item item to be moved
+   * @param newIndex new index for placement
+   * @param searchBackwards true to start from the end and search backwards
+   */
+  public void reposition(T item, int newIndex, boolean searchBackwards) {
+    if (newIndex < 0) {
+      throw new IndexOutOfBoundsException("New index can not be negative");
+    }
+    
+    synchronized (modificationLock) {
+      if (newIndex > currentData.size) {
+        throw new IndexOutOfBoundsException(newIndex + " is beyond the array's size: " + 
+                                              currentData.size);
+      }
+      
+      int index = searchBackwards ? lastIndexOf(item) : indexOf(item);
+      if (index < 0) {
+        throw new NoSuchElementException("Could not find item: " + item);
+      } else if (index == newIndex) {
+        return;
+      }
+
+      currentData = currentData.reposition(index, newIndex);
+    }
+  }
+  
+  /**
+   * Move a stored item located at an index to a new index.  Provide the size for newIndex to move 
+   * the item to the end of the list.  Otherwise all items after the new index will be shifted 
+   * right.
+   * 
+   * @param originalIndex index for item to be moved to.
+   * @param newIndex new index location for item.
+   */
+  public void reposition(int originalIndex, int newIndex) {
+    if (newIndex < 0) {
+      throw new IndexOutOfBoundsException("new index can not be negative");
+    } else if (originalIndex < 0) {
+      throw new IndexOutOfBoundsException("original index can not be negative");
+    }
+    
+    if (originalIndex == newIndex) {
+      return;
+    }
+    
+    synchronized (modificationLock) {
+      if (newIndex > currentData.size) {
+        throw new IndexOutOfBoundsException("new index " + newIndex + 
+                                              " is beyond the array's length: " + currentData.size);
+      } else if (originalIndex > currentData.size) {
+        throw new IndexOutOfBoundsException("original index " + originalIndex + 
+                                              " is beyond the array's length: " + currentData.size);
+      }
+      
+      currentData = currentData.reposition(originalIndex, newIndex);
+    }
+  }
+
+  @Override
+  public Iterator<T> iterator() {
+    return listIterator(0);
+  }
+
+  @Override
+  public ListIterator<T> listIterator() {
+    return listIterator(0);
+  }
+
+  @Override
+  public ListIterator<T> listIterator(int index) {
+    return new DataSetListIterator(currentData, index);
+  }
+
+  @Override
+  public Iterator<T> descendingIterator() {
+    final ListIterator<T> li = listIterator(currentData.size);
+    return new Iterator<T>() {
+      @Override
+      public boolean hasNext() {
+        return li.hasPrevious();
+      }
+
+      @Override
+      public T next() {
+        return li.previous();
+      }
+
+      @Override
+      public void remove() {
+        li.remove();
+      }
+    };
+  }
+
+  /**
+   * This returns a sub list from the current list.  The initial call is very cheap because it 
+   * uses the current data backing to produce (no copying necessary).
+   * <p>
+   * This differers from other subList implementations in that any modifications to this list 
+   * will be treated as a completely new list, and wont ever reflect on the source list.  This is 
+   * very different from other java.util.List implementations, and should be noted carefully.
+   * 
+   * @param fromIndex start index (inclusive) for new list to include
+   * @param toIndex end index (exclusive) to be included in new list
+   * @return new independent list
+   */
+  @Override
+  public List<T> subList(int fromIndex, int toIndex) {
+    DataSet<T> workingData = currentData;
+    
+    if (fromIndex < 0) {
+      throw new IndexOutOfBoundsException("from index can not be negative");
+    } else if (fromIndex > workingData.size) {
+      throw new IndexOutOfBoundsException("from index must be <= size: " + workingData.size);
+    } else if (toIndex > workingData.size) {
+      throw new IndexOutOfBoundsException("to index must be <= size: " + workingData.size);
+    } else if (toIndex <= fromIndex) {
+      throw new IndexOutOfBoundsException("fromIndex must be < toIndex");
+    }
+    
+    DataSet<T> newSet = new DataSet<>(workingData.dataArray, 
+                                      workingData.dataStartIndex + fromIndex, 
+                                      workingData.dataEndIndex - 
+                                        (workingData.dataEndIndex - toIndex), 
+                                      currentData.frontPadding, currentData.rearPadding);
+    
+    return new ConcurrentArrayList<>(newSet, modificationLock);
+  }
+  
+  @Override
+  public String toString() {
+    return currentData.toString();
+  }
+  
+  @SuppressWarnings("rawtypes")
+  @Override
+  public boolean equals(Object o) {
+    if (o == this) {
+      return true;
+    } else if (o instanceof ConcurrentArrayList) {
+      ConcurrentArrayList cal = (ConcurrentArrayList)o;
+      return currentData.equalsEquivelent(cal.currentData);
+    } else if (o instanceof List) {
+      List list = (List)o;
+      if (list.size() != this.size()) {
+        return false;
+      }
+      Iterator thisIt = this.iterator();
+      Iterator listIt = list.iterator();
+      while (thisIt.hasNext() && listIt.hasNext()) {
+        if (! thisIt.next().equals(listIt.next())) {
+          return false;
+        }
+      }
+      if (thisIt.hasNext() || listIt.hasNext()) {
+        return false;
+      }
+      return true;
+    } else {
+      return false;
+    }
+  }
+  
+  @Override
+  public int hashCode() {
+    return currentData.hashCode();
+  }
+  
+  /**
+   * This is an iterator implementation that is designed to iterate over a given dataSet.  
+   * Modifiable actions will attempt to make changes to the parent class.
+   * 
+   * @since 1.0.0
+   */
+  protected class DataSetListIterator implements ListIterator<T> {
+    private DataSet<T> dataSet;
+    private int nextIndex;
+
+    public DataSetListIterator(DataSet<T> dataSet, int index) {
+      this.dataSet = dataSet;
+      nextIndex = index;
+    }
+
+    @Override
+    public boolean hasNext() {
+      return nextIndex < dataSet.size;
+    }
+
+    @Override
+    public T next() {
+      verifyPosition();
+      
+      return dataSet.get(nextIndex++);
+    }
+
+    @Override
+    public boolean hasPrevious() {
+      return nextIndex - 1 >= 0;
+    }
+
+    @Override
+    public T previous() {
+      nextIndex--;
+      
+      verifyPosition();
+      
+      return dataSet.get(nextIndex);
+    }
+    
+    private void verifyPosition() {
+      if (nextIndex < 0 || nextIndex >= dataSet.size) {
+        throw new NoSuchElementException();
+      }
+    }
+
+    @Override
+    public int nextIndex() {
+      return nextIndex;
+    }
+
+    @Override
+    public int previousIndex() {
+      return nextIndex - 1;
+    }
+
+    @Override
+    public void remove() {
+      synchronized (modificationLock) {
+        // you can not cause concurrent modification exceptions with this implementation
+        if (currentData == dataSet) {
+          ConcurrentArrayList.this.remove(--nextIndex);
+          
+          dataSet = currentData;
+        } else {
+          int globalIndex = ConcurrentArrayList.this.indexOf(dataSet.get(nextIndex - 1));
+          if (globalIndex >= 0) {
+            ConcurrentArrayList.this.remove(globalIndex);
+          }
+        }
+      }
+    }
+
+    @Override
+    public void set(T e) {
+      synchronized (modificationLock) {
+        if (currentData == dataSet) {
+          ConcurrentArrayList.this.set(nextIndex - 1, e);
+          
+          dataSet = currentData;
+        } else {
+          int globalIndex = ConcurrentArrayList.this.indexOf(dataSet.get(nextIndex - 1));
+          if (globalIndex >= 0) {
+            ConcurrentArrayList.this.set(globalIndex, e);
+          }
+        }
+      }
+    }
+
+    @Override
+    public void add(T e) {
+      synchronized (modificationLock) {
+        if (currentData == dataSet) {
+          ConcurrentArrayList.this.add(nextIndex, e);
+          
+          nextIndex++;
+          
+          dataSet = currentData;
+        } else {
+          int globalIndex = ConcurrentArrayList.this.indexOf(dataSet.get(nextIndex - 1));
+          if (globalIndex >= 0) {
+            ConcurrentArrayList.this.add(globalIndex + 1, e);
+          }
+        }
+      }
+    }
+  }
+  
+  /**
+   * This is designed to be an immutable version of the list.  Modifiable actions will return a 
+   * new instance that is based off this one.  Because the array may change in areas outside of 
+   * the scope of this dataArray, it is expected that the modificationLock is held while any 
+   * modifiable operations are happening.
+   * 
+   * @since 1.0.0
+   * @param <T> type of object that is held
+   */
+  protected static class DataSet<T> {
+    protected final Object[] dataArray;
+    protected final int dataStartIndex; // inclusive
+    protected final int dataEndIndex;   // exclusive
+    protected final int size;
+    private int frontPadding; // locked around modificationLock
+    private int rearPadding; // locked around modificationLock
+    
+    protected DataSet(Object[] dataArray, int frontPadding, int rearPadding) {
+      this(dataArray, frontPadding, dataArray.length - rearPadding, frontPadding, rearPadding);
+    }
+
+    protected DataSet(Object[] dataArray, 
+                      int dataStartIndex, int dataEndIndex, 
+                      int frontPadding, int rearPadding) {
+      this.dataArray = dataArray;
+      this.dataStartIndex = dataStartIndex;
+      this.dataEndIndex = dataEndIndex;
+      this.size = dataEndIndex - dataStartIndex;
+      this.frontPadding = frontPadding;
+      this.rearPadding = rearPadding;
+    }
+    
+    /**
+     * Returns a new {@link DataSet} that contains only relevant and active items in the data 
+     * array.  The returned DataSet has the same set front and rear padding, so additional 
+     * modifications will expand the array based off those set values.
+     * 
+     * @return New trimmed {@link DataSet}, or {@code this} if already trimmed
+     */
+    public DataSet<T> trimToSize() {
+      if (dataStartIndex == 0 && dataEndIndex == dataArray.length) {
+        return this;
+      } else {
+        Object[] newData = new Object[size];
+        System.arraycopy(dataArray, dataStartIndex, newData, 0, size);
+        return new DataSet<>(newData, 0, size, frontPadding, rearPadding);
+      }
+    }
+
+    /**
+     * Call to reposition one index to a new index.
+     * 
+     * @param origCurrentIndex original index to move
+     * @param origNewIndex new index position
+     * @return a new {@link DataSet} which represents the change (or the same reference if the inputs are a no-op)
+     */
+    public DataSet<T> reposition(int origCurrentIndex, int origNewIndex) {
+      if (size == 1) {
+        // no-op, moving single item to same position
+        return this;
+      } else if (origNewIndex == size && origCurrentIndex == size - 1) {
+        // no-op, moving end item to end
+        return this;
+      }
+      
+      int currentIndex = origCurrentIndex + dataStartIndex;
+      int newIndex = origNewIndex + dataStartIndex;
+      
+      if (newIndex > currentIndex) {  // move right
+        Object[] newData; // will not be allocated till necessary
+        
+        if (newIndex == dataEndIndex) {
+          if (currentIndex == dataStartIndex && 
+              dataArray.length - 1 > dataEndIndex && 
+              dataArray[dataEndIndex] == null) {
+            // reposition front item to end without an array copy
+            dataArray[dataEndIndex] = dataArray[currentIndex];
+            
+            return new DataSet<>(dataArray, dataStartIndex + 1, dataEndIndex + 1, 
+                                 frontPadding, rearPadding);
+          } else {
+            newData = new Object[size + frontPadding + rearPadding];
+            
+            // moving to end can be done with two array copies at most
+            System.arraycopy(dataArray, dataStartIndex, 
+                             newData, frontPadding, origCurrentIndex);
+            System.arraycopy(dataArray, currentIndex + 1, 
+                             newData, frontPadding + origCurrentIndex, 
+                             size - origCurrentIndex - 1);
+          }
+        } else {
+          newData = new Object[size + frontPadding + rearPadding];
+          
+          // work backwards
+          System.arraycopy(dataArray, newIndex,   // write from new position to end
+                           newData, frontPadding + origNewIndex, 
+                           size - origNewIndex);
+          System.arraycopy(dataArray, currentIndex + 1, // write from removed position to new position
+                           newData, frontPadding + origCurrentIndex, 
+                           origNewIndex - origCurrentIndex);
+          System.arraycopy(dataArray, dataStartIndex, // write from start to removed position
+                           newData, frontPadding, 
+                           origCurrentIndex);
+        }
+        
+        newData[frontPadding + origNewIndex - 1] = dataArray[currentIndex];
+        
+        return new DataSet<>(newData, frontPadding, rearPadding);
+      } else if (newIndex < currentIndex) { // move left
+        Object[] newData; // will not be allocated till necessary
+        
+        if (newIndex == dataStartIndex) {
+          if (dataStartIndex > 0 && 
+              currentIndex == dataEndIndex - 1 && 
+              dataArray[dataStartIndex - 1] == null) {
+            // reposition the end item to the front without an array copy
+            dataArray[dataStartIndex - 1] = dataArray[currentIndex];
+            
+            return new DataSet<>(dataArray, dataStartIndex - 1, dataEndIndex - 1, 
+                                 frontPadding, rearPadding);
+          } else {
+            newData = new Object[size + frontPadding + rearPadding];
+            
+            // moving to front can be done with two array copies at most
+            System.arraycopy(dataArray, dataStartIndex, 
+                             newData, frontPadding + 1, origCurrentIndex);
+            System.arraycopy(dataArray, currentIndex + 1, 
+                             newData, frontPadding + origCurrentIndex + 1, 
+                             dataEndIndex - currentIndex - 1);
+          }
+        } else {
+          newData = new Object[size + frontPadding + rearPadding];
+          
+          // work forward
+          System.arraycopy(dataArray, dataStartIndex,   // write from start to new position
+                           newData, frontPadding, origNewIndex);
+          System.arraycopy(dataArray, newIndex,   // write from new position to current position
+                           newData, frontPadding + origNewIndex + 1, 
+                           origCurrentIndex - origNewIndex);
+          if (origCurrentIndex < size - 1) {
+            System.arraycopy(dataArray, currentIndex + 1, // write from current position to end
+                             newData, frontPadding + origCurrentIndex + 1, 
+                             size - origCurrentIndex - 1);
+          }
+        }
+        
+        newData[frontPadding + origNewIndex] = dataArray[currentIndex];
+        
+        return new DataSet<>(newData, frontPadding, rearPadding);
+      } else {
+        // no-op, moving to same position
+        return this;
+      }
+    }
+    
+    /**
+     * Used to get a newly sized array which copies the beginning items till the new size is 
+     * reached (or all items if the newSize is larger).  The newly created array will also respect 
+     * the front and rear padding, which is NOT included in the {@code newSize} provided.
+     * 
+     * @param newSize size for data within the new array
+     * @return a new array
+     */
+    private Object[] getArrayCopy(int newSize) {
+      Object[] newData = new Object[newSize + frontPadding + rearPadding];
+
+      System.arraycopy(dataArray, dataStartIndex, 
+                       newData, frontPadding, Math.min(size, newSize));
+      
+      return newData;
+    }
+
+    /**
+     * Returns the item at a given index, this function handles the front padding for you.
+     * 
+     * @param index index of item
+     * @return stored item
+     */
+    @SuppressWarnings("unchecked")
+    public T get(int index) {
+      return (T)dataArray[index + dataStartIndex];
+    }
+
+    /**
+     * Call to check for the index of a given item.  The return index has already had the front 
+     * padding removed from the actual index.
+     * 
+     * @param o Object to search for
+     * @return index of item, or -1 if not found
+     */
+    public int indexOf(Object o) {
+      for (int i = dataStartIndex; i < dataEndIndex; i++) {
+        if (dataArray[i].equals(o)) {
+          return i - dataStartIndex;
+        }
+      }
+      
+      return -1;
+    }
+
+    /**
+     * Call to check for the last index of a given item.  The return index has already had the 
+     * front padding removed from the actual index.
+     * 
+     * @param o Object to search for
+     * @return index of item, or -1 if not found
+     */
+    public int lastIndexOf(Object o) {
+      for (int i = dataEndIndex - 1; i >= dataStartIndex; i--) {
+        if (dataArray[i].equals(o)) {
+          return i - dataStartIndex;
+        }
+      }
+      
+      return -1;
+    }
+
+    /**
+     * Sets a specific index with a given element.
+     * 
+     * @param index index to set the item at
+     * @param element element to place in the array
+     * @return a new {@link DataSet} which represents the change
+     */
+    public DataSet<T> set(int index, T element) {
+      if (index == size) {
+        return addToEnd(element);
+      } else {
+        Object[] newData = getArrayCopy(size);
+        newData[index + frontPadding] = element;
+      
+        return new DataSet<>(newData, frontPadding, rearPadding);
+      }
+    }
+
+    /**
+     * Adds an item to the front of the structure.
+     * 
+     * @param e item to be added
+     * @return a new {@link DataSet} which represents the change
+     */
+    public DataSet<T> addToFront(T e) {
+      if (dataStartIndex > 0 && dataArray[dataStartIndex - 1] == null) {
+        // there is space in the current array
+        dataArray[dataStartIndex - 1] = e;
+        
+        return new DataSet<>(dataArray, 
+                             dataStartIndex - 1, dataEndIndex, 
+                             frontPadding, rearPadding);
+      } else {
+        Object[] newData = new Object[size + 1 + frontPadding + rearPadding];
+        
+        newData[frontPadding] = e;
+        System.arraycopy(dataArray, dataStartIndex, newData, frontPadding + 1, size);
+        
+        return new DataSet<>(newData, frontPadding, rearPadding);
+      }
+    }
+    
+    /**
+     * Adds an item to the end of the structure.
+     * 
+     * @param e item to be added
+     * @return a new {@link DataSet} which represents the change
+     */
+    public DataSet<T> addToEnd(T e) {
+      if (dataArray.length - 1 >= dataEndIndex && dataArray[dataEndIndex] == null) {
+        // there is space in the current array
+        dataArray[dataEndIndex] = e;
+        
+        return new DataSet<>(dataArray, dataStartIndex, dataEndIndex + 1, frontPadding, rearPadding);
+      } else {
+        Object[] newData = getArrayCopy(size + 1);
+        newData[size + frontPadding] = e;
+        
+        return new DataSet<>(newData, frontPadding, rearPadding);
+      }
+    }
+
+    /**
+     * Adds an item at a specific index within the structure.
+     * 
+     * @param origIndex index to place the item
+     * @param element item to be added
+     * @return a new {@link DataSet} which represents the change
+     */
+    public DataSet<T> add(int origIndex, T element) {
+      if (origIndex == 0) { // add to front
+        return addToFront(element);
+      } else if (origIndex == size) { // add to end
+        return addToEnd(element);
+      } else {  // add into middle
+        Object[] newData = new Object[size + 1 + frontPadding + rearPadding];
+        System.arraycopy(dataArray, dataStartIndex, newData, frontPadding, origIndex);
+        newData[frontPadding + origIndex] = element;
+        System.arraycopy(dataArray, dataStartIndex + origIndex, 
+                         newData, frontPadding + origIndex + 1, size - origIndex);
+        
+        return new DataSet<>(newData, frontPadding, rearPadding);
+      }
+    }
+
+    /**
+     * Adds all items within the collection to the end of the structure.
+     * 
+     * @param c collection to add items from
+     * @return a new {@link DataSet} which represents the change, or this reference if the collection is empty
+     */
+    public DataSet<T> addAll(Collection<? extends T> c) {
+      return addAll(size, c);
+    }
+
+    /**
+     * Adds all items within the collection at a given index.
+     * 
+     * @param origIndex index to start insertion at
+     * @param c collection to add items from
+     * @return a new {@link DataSet} which represents the change, or this reference if the collection is empty
+     */
+    public DataSet<T> addAll(int origIndex, Collection<? extends T> c) {
+      if (c == null || c.isEmpty()) {
+        return this;
+      }
+      
+      Object[] toAdd = c.toArray();
+      if (origIndex == 0) {
+        // add to front
+        if (toAdd.length <= dataStartIndex && 
+            dataArray[dataStartIndex - 1] == null) {  // if previous one is null, all previous ones are null
+          // we can copy the new items in, without copying our existing array
+          System.arraycopy(toAdd, 0, dataArray, dataStartIndex - toAdd.length, toAdd.length);
+          
+          return new DataSet<>(dataArray, 
+                               dataStartIndex - toAdd.length, dataEndIndex, 
+                               frontPadding, rearPadding);
+        } else {
+          Object[] newData = new Object[size + toAdd.length + frontPadding + rearPadding];
+          
+          System.arraycopy(toAdd, 0, newData, frontPadding, toAdd.length);
+          System.arraycopy(dataArray, dataStartIndex, 
+                           newData, frontPadding + toAdd.length, size);
+          
+          return new DataSet<>(newData, frontPadding, rearPadding);
+        }
+      } else if (origIndex == size) {
+        // add to end
+        if (dataEndIndex + toAdd.length <= dataArray.length && 
+            dataArray[dataEndIndex] == null) {  // if next one is null, all future ones should be
+          // we can copy the new items in, without copying our existing array
+          System.arraycopy(toAdd, 0, dataArray, dataEndIndex, toAdd.length);
+
+          return new DataSet<>(dataArray, 
+                               dataStartIndex, dataEndIndex + toAdd.length, 
+                               frontPadding, rearPadding);
+        } else {
+          Object[] newData = getArrayCopy(size + toAdd.length);
+          
+          System.arraycopy(toAdd, 0, newData, size + frontPadding, toAdd.length);
+          
+          return new DataSet<>(newData, frontPadding, rearPadding);
+        }
+      } else {
+        // add in middle
+        Object[] newData = new Object[size + toAdd.length + frontPadding + rearPadding];
+        
+        System.arraycopy(dataArray, dataStartIndex, newData, frontPadding, origIndex);
+        System.arraycopy(toAdd, 0, newData, frontPadding + origIndex, toAdd.length);
+        System.arraycopy(dataArray, dataStartIndex + origIndex, 
+                         newData, frontPadding + origIndex + toAdd.length, size - origIndex);
+        
+        return new DataSet<>(newData, frontPadding, rearPadding);
+      }
+    }
+    
+    /**
+     * Removes a specific index from the collection.
+     * 
+     * @param origIndex index to remove from
+     * @return a new {@link DataSet} which represents the change
+     */
+    public DataSet<T> remove(int origIndex) {
+      int index = origIndex + dataStartIndex;
+      
+      if (index == dataStartIndex) {  // remove from front without copy
+        return new DataSet<>(dataArray, 
+                             dataStartIndex + 1, dataEndIndex, 
+                             frontPadding, rearPadding);
+      } else if (index == dataEndIndex - 1) {  // remove from end without copy
+        return new DataSet<>(dataArray, 
+                             dataStartIndex, dataEndIndex - 1, 
+                             frontPadding, rearPadding);
+      } else {  // remove from middle
+        Object[] newData = new Object[size - 1 + frontPadding + rearPadding];
+        
+        System.arraycopy(dataArray, dataStartIndex, newData, frontPadding, origIndex);
+        System.arraycopy(dataArray, index + 1, 
+                         newData, frontPadding + origIndex, size - origIndex - 1);
+        
+        return new DataSet<>(newData, frontPadding, rearPadding);
+      }
+    }
+
+    /**
+     * Removes a specific index from the collection.
+     * 
+     * @param c Collection which contains items to be removed
+     * @return a new {@link DataSet} which represents the change, or the same reference if no modification was necessary
+     */
+    public DataSet<T> removeAll(Collection<?> c) {
+      Object[] resultArray = null;  // will only be allocated once modification occurs
+      
+      int i = frontPadding;
+      for (int currentIndex = 0; currentIndex < size; currentIndex++) {
+        Object currItem = this.get(currentIndex);
+        if (! c.contains(currItem)) {
+          if (resultArray != null) {
+            resultArray[i++] = currItem;
+          } else {
+            /* if result array has not been created yet, we will do a single array copy
+             * once a modification occurs. 
+             */
+            i++;
+          }
+        } else {
+          // modification occurred, create array and copy
+          if (resultArray == null) {
+            resultArray = new Object[size + frontPadding + rearPadding];
+            System.arraycopy(dataArray, dataStartIndex, resultArray, frontPadding, i);
+          }
+        }
+      }
+      
+      if (resultArray != null) {
+        return new DataSet<>(resultArray, frontPadding, i, frontPadding, rearPadding);
+      } else {
+        return this;
+      }
+    }
+
+    /**
+     * Keeps only the items in the provided collection.
+     * 
+     * @param c Collection to examine for items to retain
+     * @return a new {@link DataSet} which represents the change, or the same reference if no modification was necessary
+     */
+    public DataSet<T> retainAll(Collection<?> c) {
+      Object[] resultArray = null;  // will only be allocated once modification occurs
+      
+      int i = frontPadding;
+      for (int currentIndex = 0; currentIndex < size; currentIndex++) {
+        Object currItem = this.get(currentIndex);
+        if (c.contains(currItem)) {
+          if (resultArray != null) {
+            resultArray[i++] = currItem;
+          } else {
+            i++;
+          }
+        } else {
+          // modification occurred, create array and copy
+          if (resultArray == null) {
+            resultArray = new Object[size + frontPadding + rearPadding];
+            System.arraycopy(dataArray, dataStartIndex, resultArray, frontPadding, i);
+          }
+        }
+      }
+      
+      if (resultArray != null) {
+        return new DataSet<>(resultArray, frontPadding, i, frontPadding, rearPadding);
+      } else {
+        return this;
+      }
+    }
+    
+    @Override
+    public boolean equals(Object o) {
+      if (this == o) {
+        return true;
+      } else if (o instanceof DataSet) {
+        @SuppressWarnings("rawtypes")
+        DataSet ds = (DataSet)o;
+        return equalsEquivelent(ds);
+      } else {
+        return false;
+      }
+    }
+    
+    /**
+     * Call to see if the lists are equivalently equal, meaning that they have the same items in 
+     * the same order.  This is what most equals operations for lists expect.
+     * 
+     * @param ds Other DataSet to compare against (can't be {@code null})
+     * @return {@code true} if they are equal
+     */
+    @SuppressWarnings("rawtypes")
+    public boolean equalsEquivelent(DataSet ds) {
+      if (this.size != ds.size) {
+        return false;
+      }
+      
+      for (int i = 0; i < size; i++) {
+        Object thisItem = this.get(i);
+        Object thatItem = ds.get(i);
+        if ((thisItem == null && thatItem != null) || 
+            (thisItem != null && ! thisItem.equals(thatItem))) {
+          return false;
+        }
+      }
+      return true;
+    }
+    
+    /**
+     * This is a call to check if the DataSet is exactly equal.  This is unique for the design of 
+     * this collection.  This can be a quicker check, but may result in saying DataSet's are not 
+     * equal, when they basically are equal.
+     * 
+     * @param ds Other DataSet to compare against (can't be null)
+     * @return {@code true} if they are equal
+     */
+    @SuppressWarnings("rawtypes")
+    public boolean equalsExactly(DataSet ds) {
+      if (this == ds) {
+        return true;
+      } else {
+        if (dataStartIndex != ds.dataStartIndex || 
+            dataEndIndex != ds.dataEndIndex || 
+            dataArray.length != ds.dataArray.length) {
+          return false;
+        } else {
+          for (int i = 0; i < dataArray.length; i++) {
+            if ((dataArray[i] == null && ds.dataArray[i] != null) || 
+                (dataArray[i] != null && ! dataArray[i].equals(ds.dataArray[i]))) {
+              return false;
+            }
+          }
+          return true;
+        }
+      }
+    }
+    
+    @Override
+    public int hashCode() {
+      int hashCode = 1;
+      for (int i = dataStartIndex; i < dataEndIndex; i++) {
+        hashCode = HASH_CODE_PRIME_NUMBER * hashCode + dataArray[i].hashCode();
+      }
+      
+      return hashCode;
+    }
+    
+    @Override
+    public String toString() {
+      StringBuilder result = new StringBuilder();
+      
+      result.append('[');
+      for (int i = 0; i < dataArray.length; i++) {
+        if (i != 0) {
+          result.append(", ");
+        }
+        if (i == dataStartIndex) {
+          result.append('S');
+        }
+        result.append(i).append('-').append(dataArray[i]);
+        if (i == dataEndIndex - 1) {
+          result.append('E');
+        }
+      }
+      result.append(']');
+      
+      return result.toString();
+    }
+  }
+}
diff --git a/src/main/java/org/threadly/util/ArgumentVerifier.java b/src/main/java/org/threadly/util/ArgumentVerifier.java
new file mode 100644
index 000000000..945112ff5
--- /dev/null
+++ b/src/main/java/org/threadly/util/ArgumentVerifier.java
@@ -0,0 +1,68 @@
+package org.threadly.util;
+
+/**
+ * Simple class to do some argument verifying which is common within threadly.  This is designed 
+ * to primarily reduce bulk/repeated code throughout the base, as well as to ensure that thrown 
+ * exceptions have a common format for the exception message.
+ * 
+ * @since 2.4.0
+ */
+public class ArgumentVerifier {
+  /**
+   * Verifies the provided argument is not null, if it is an {@link IllegalArgumentException} is 
+   * thrown.
+   * 
+   * @param arg Object to check against to not be {@code null}
+   * @param name Name to provide the argument in the message of the thrown exception
+   * @throws IllegalArgumentException Thrown if the arg is {@code null}
+   */
+  public static void assertNotNull(Object arg, String name) {
+    if (arg == null) {
+      throw new IllegalArgumentException(StringUtils.nullToEmpty(name) + " can not be null");
+    }
+  }
+  
+  /**
+   * Verifies the provided argument is not negative (zero is okay).  If it is less than zero an 
+   * {@link IllegalArgumentException} is thrown.
+   * 
+   * @param val Value to verify against
+   * @param name Name to provide the argument in the message of the thrown exception
+   * @throws IllegalArgumentException Thrown if value is less than zero
+   */
+  public static void assertNotNegative(double val, String name) {
+    if (val < 0) {
+      throw new IllegalArgumentException(StringUtils.nullToEmpty(name) + " can not be negative: " + val);
+    }
+  }
+  
+  /**
+   * Verifies the provided argument is greater than zero.  If it is less than one an 
+   * {@link IllegalArgumentException} is thrown.
+   * 
+   * @param val Value to verify against
+   * @param name Name to provide the argument in the message of the thrown exception
+   * @throws IllegalArgumentException Thrown if value is less than one
+   */
+  public static void assertGreaterThanZero(double val, String name) {
+    if (val <= 0) {
+      throw new IllegalArgumentException(StringUtils.nullToEmpty(name) + " must be > 0: " + val);
+    }
+  }
+  
+  /**
+   * Verifies the provided argument is less than the compare value.  If it is greater than or 
+   * equal to the compare value an {@link IllegalArgumentException} is thrown.
+   * 
+   * @param val Value to verify
+   * @param compareVal value to compare against
+   * @param name Name to provide the argument in the message of the thrown exception
+   * @throws IllegalArgumentException Thrown if value is greather than or equal to compareVal
+   */
+  public static void assertLessThan(double val, double compareVal, String name) {
+    if (val >= compareVal) {
+      throw new IllegalArgumentException(StringUtils.nullToEmpty(name) + 
+                                           " must be < " + compareVal + ": " + val);
+    }
+  }
+}
diff --git a/src/main/java/org/threadly/util/StringUtils.java b/src/main/java/org/threadly/util/StringUtils.java
new file mode 100644
index 000000000..e3623184d
--- /dev/null
+++ b/src/main/java/org/threadly/util/StringUtils.java
@@ -0,0 +1,186 @@
+package org.threadly.util;
+
+import java.util.Optional;
+import java.util.concurrent.ThreadLocalRandom;
+import java.util.function.Predicate;
+
+/**
+ * Some small utilities and constants around handling strings.
+ * 
+ * @since 2.1.0
+ */
+public class StringUtils {
+  protected static final String RAND_CHARS = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
+  
+  /**
+   * Check to see if all characters in a provided string match to a given {@link Predicate}.  This 
+   * can be easily used when provided predicates from {@link Character}.  For example providing 
+   * {@code Character::isLetter} for the predicate will verify all characters in the string are 
+   * letters.
+   * 
+   * @since 5.14
+   * @param p Character test
+   * @param s CharSequence to check against
+   * @return {@code true} if predicate returned true for every character in string
+   */
+  public static boolean allCharsMatch(Predicate<Character> p, CharSequence s) {
+    for (int i = 0; i < s.length(); i++) {
+      if (! p.test(s.charAt(i))) {
+        return false;
+      }
+    }
+    return true;
+  }
+  
+  /**
+   * Check to see if any characters in a provided string match to a given {@link Predicate}.  This 
+   * can be easily used when provided predicates from {@link Character}.  For example providing 
+   * {@code Character::isDigit} for the predicate to see if this string contains any numbers.
+   * 
+   * @since 5.14
+   * @param p Character test
+   * @param s CharSequence to check against
+   * @return {@code true} if predicate returned true for any characters in the string
+   */
+  public static boolean anyCharsMatch(Predicate<Character> p, CharSequence s) {
+    for (int i = 0; i < s.length(); i++) {
+      if (p.test(s.charAt(i))) {
+        return true;
+      }
+    }
+    return false;
+  }
+  
+  /**
+   * Makes sure a given string is not {@code null}.  If it is not {@code null}, the provided string 
+   * is immediately returned.  If it IS {@code null}, then an empty string is returned.
+   * 
+   * @since 4.2.0
+   * @param input String which should be returned if not {@code null}
+   * @return The original string if not {@code null}, otherwise an empty string
+   */
+  public static String nullToEmpty(String input) {
+    if (input != null) {
+      return input;
+    } else {
+      return "";
+    }
+  }
+
+  /**
+   * Converts an empty string into a {@code null}.  If it is not empty or {@code null}, the 
+   * provided string is immediately returned.
+   * 
+   * @since 4.2.0
+   * @param input String which should be returned if not {@code null} or empty
+   * @return The original string if not empty, otherwise {@code null}
+   */
+  public static String emptyToNull(String input) {
+    if (input == null || input.isEmpty()) {
+      return null;
+    } else {
+      return input;
+    }
+  }
+  
+  /**
+   * Check if the provided string is either {@code null} or empty.
+   * 
+   * @since 4.2.0
+   * @param input String to check against
+   * @return {@code true} if the provided string is {@code null} or has no content
+   */
+  public static boolean isNullOrEmpty(String input) {
+    return input == null || input.isEmpty();
+  }
+  
+  /**
+   * Simple utility function for returning an {@link Optional} that if contents present are 
+   * guaranteed to not be empty.  Basically taking the empty case into consideration in addition 
+   * to {@link Optional#ofNullable(Object)}'s normal {@code null} check.
+   * 
+   * @since 5.4
+   * @param input String to be contained in returned {@link Optional} if not null or empty
+   * @return Optional which if present contains a non-empty String
+   */
+  public static Optional<String> nonEmptyOptional(String input) {
+    if (isNullOrEmpty(input)) {
+      return Optional.empty();
+    } else {
+      return Optional.of(input);
+    }
+  }
+  
+  /**
+   * Pads the start of the provided string with the provided character until a minimum length is 
+   * reached.  If the provided string is greater than or equal to the minLength it will be returned 
+   * without modification.  If the provided string is {@code null} it will be returned as an empty 
+   * string, padded to the minimum length.
+   * 
+   * @since 4.2.0
+   * @param sourceStr String to start from, this will be the end of the returned result string
+   * @param minLength Minimum number of characters the returned string should be
+   * @param padChar Character to pad on to the start of to reach the minimum length
+   * @return A non-null string that is at least the length requested
+   */
+  public static String padStart(String sourceStr, int minLength, char padChar) {
+    sourceStr = nullToEmpty(sourceStr);
+    if (sourceStr.length() >= minLength) {
+      return sourceStr;
+    } else {
+      StringBuilder sb = new StringBuilder(minLength);
+      int padCount = minLength - sourceStr.length();
+      while (sb.length() < padCount) {
+        sb.append(padChar);
+      }
+      sb.append(sourceStr);
+      return sb.toString();
+    }
+  }
+
+  
+  /**
+   * Pads the end of the provided string with the provided character until a minimum length is 
+   * reached.  If the provided string is greater than or equal to the minLength it will be returned 
+   * without modification.  If the provided string is {@code null} it will be returned as an empty 
+   * string, padded to the minimum length.
+   * 
+   * @since 4.2.0
+   * @param sourceStr String to start from, this will be the start of the returned result string
+   * @param minLength Minimum number of characters the returned string should be
+   * @param padChar Character to pad on to the end of to reach the minimum length
+   * @return A non-null string that is at least the length requested
+   */
+  public static String padEnd(String sourceStr, int minLength, char padChar) {
+    sourceStr = nullToEmpty(sourceStr);
+    if (sourceStr.length() >= minLength) {
+      return sourceStr;
+    } else {
+      StringBuilder sb = new StringBuilder(minLength);
+      sb.append(sourceStr);
+      while (sb.length() < minLength) {
+        sb.append(padChar);
+      }
+      return sb.toString();
+    }
+  }
+  
+  /**
+   * Produces a random string of the provided length.  This can be useful for unit testing, or any 
+   * other time the string content is not important.  The returned string will be comprised of 
+   * only alphanumeric characters.
+   * 
+   * @param length Number of characters the resulting string should be.
+   * @return A string comprised of random characters of the specified length
+   */
+  public static String makeRandomString(int length) {
+     StringBuilder sb = new StringBuilder(length);
+     
+     for(int i = 0; i < length; i++) {
+       char randChar = RAND_CHARS.charAt(ThreadLocalRandom.current().nextInt(RAND_CHARS.length()));
+       sb.append(randChar);
+     }
+     
+     return sb.toString();
+  }
+}
-- 
2.34.1

